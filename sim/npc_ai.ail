module sim/npc_ai

-- Import types (imports fixed in v0.4.9)
import sim/protocol (Coord)

-- Import Rand for true randomness (v0.5.0)
import std/rand (rand_int)

-- Direction type for movement
export type Direction = North | South | East | West

-- Movement behavior pattern (ADT)
export type MovementPattern =
    | PatternStatic                  -- NPC stays in place
    | PatternRandomWalk(int)         -- move every N ticks
    | PatternPatrol([Direction])     -- follow path of directions

-- NPC entity with movement state
export type NPC = {
    id: int,
    pos: Coord,
    pattern: MovementPattern,
    moveCounter: int,    -- ticks until next move
    patrolIndex: int     -- current index in patrol path
}

-- Check if position is within bounds
export pure func isInBounds(x: int, y: int, width: int, height: int) -> bool
tests [
    ((0, 0, 10, 10), true),
    ((9, 9, 10, 10), true),
    ((10, 5, 10, 10), false),
    ((-1, 5, 10, 10), false),
    ((5, -1, 10, 10), false)
] {
    x >= 0 && x < width && y >= 0 && y < height
}

-- Get X offset for a direction (ADT test fix v0.5.0)
pure func directionDx(dir: Direction) -> int
tests [(North, 0), (South, 0), (East, 1), (West, -1)] {
    match dir {
        North => 0,
        South => 0,
        East => 1,
        West => -1
    }
}

-- Get Y offset for a direction
pure func directionDy(dir: Direction) -> int
tests [(North, -1), (South, 1), (East, 0), (West, 0)] {
    match dir {
        North => -1,
        South => 1,
        East => 0,
        West => 0
    }
}

-- Convert index (0-3) to direction (deterministic "random")
pure func indexToDirection(idx: int) -> Direction {
    match idx % 4 {
        0 => North,
        1 => South,
        2 => East,
        _ => West
    }
}

-- Get length of a direction list (for patrol path cycling)
pure func pathLength(path: [Direction]) -> int {
    match path {
        [] => 0,
        _ :: rest => 1 + pathLength(rest)
    }
}

-- Get direction at index from path (0-indexed, returns North if out of bounds)
pure func pathGet(path: [Direction], idx: int) -> Direction {
    match path {
        [] => North,
        dir :: rest => if idx <= 0 then dir else pathGet(rest, idx - 1)
    }
}

-- Create NPC with updated position (record update v0.5.0)
pure func npcWithPos(npc: NPC, newX: int, newY: int) -> NPC {
    { npc | pos: { x: newX, y: newY } }
}

-- Create NPC with updated counter (record update v0.5.0)
pure func npcWithCounter(npc: NPC, counter: int) -> NPC {
    { npc | moveCounter: counter }
}

-- Try to move NPC in a direction, return new NPC (or same if blocked)
-- Direct nested access (TVar2 list pattern fix v0.5.0)
export pure func tryMoveDirection(npc: NPC, dir: Direction, width: int, height: int) -> NPC {
    let dx = directionDx(dir);
    let dy = directionDy(dir);
    let newX = npc.pos.x + dx;
    let newY = npc.pos.y + dy;
    if isInBounds(newX, newY, width, height) then
        npcWithPos(npc, newX, newY)
    else
        npc
}

-- Update random walk NPC for one tick (uses Rand effect for true randomness)
func updateRandomWalk(npc: NPC, interval: int, width: int, height: int) -> NPC ! {Rand} {
    if npc.moveCounter <= 0 then {
        -- Time to move! Pick truly random direction (0-3 for 4 directions)
        let dirIndex = rand_int(0, 3);
        let dir = indexToDirection(dirIndex);
        let movedNpc = tryMoveDirection(npc, dir, width, height);
        -- Reset counter to interval
        npcWithCounter(movedNpc, interval)
    } else
        -- Decrement counter
        npcWithCounter(npc, npc.moveCounter - 1)
}

-- Update patrol NPC for one tick (moves every 20 ticks along path)
pure func updatePatrol(npc: NPC, path: [Direction], width: int, height: int) -> NPC {
    let len = pathLength(path);
    if len <= 0 then
        npc  -- Empty path, stay put
    else if npc.moveCounter <= 0 then {
        -- Time to move! Get direction from path at current index
        let dir = pathGet(path, npc.patrolIndex);
        let movedNpc = tryMoveDirection(npc, dir, width, height);
        -- Advance patrol index (cycle using modulo)
        let nextIndex = (npc.patrolIndex + 1) % len;
        { movedNpc | patrolIndex: nextIndex, moveCounter: 20 }
    } else
        -- Decrement counter
        npcWithCounter(npc, npc.moveCounter - 1)
}

-- Update single NPC for one tick based on its pattern
export func updateNPC(npc: NPC, width: int, height: int) -> NPC ! {Rand} {
    match npc.pattern {
        PatternStatic => npc,
        PatternRandomWalk(interval) => updateRandomWalk(npc, interval, width, height),
        PatternPatrol(path) => updatePatrol(npc, path, width, height)
    }
}

-- Update all NPCs recursively
export func updateAllNPCs(npcs: [NPC], width: int, height: int) -> [NPC] ! {Rand} {
    match npcs {
        [] => [],
        npc :: rest => updateNPC(npc, width, height) :: updateAllNPCs(rest, width, height)
    }
}
