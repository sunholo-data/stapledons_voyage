module sim/step

-- Import types from protocol and world modules (imports fixed in v0.4.9)
import sim/protocol (FrameInput, FrameOutput, DrawCmd, Rect, Coord, PlayerAction, ActionNone, Camera, CircleRGBA, Text)
import sim/world (World, PlanetState, Tile, Selection, SelectionNone, SelectionTile, ViewMode, ViewBridge, ViewPlanet, ViewGalaxyMap)
import sim/npc_ai (NPC, PatternStatic, PatternRandomWalk, PatternPatrol, Direction, North, South, East, West, updateAllNPCs)
import sim/bridge (BridgeState, initBridge, renderBridge, stepBridge)
import sim/starmap (initLocalCatalog, Star, Vec3, spectralColor, StarCatalog)

-- Import effects (v0.5.0)
import std/rand (rand_int)

-- Helper: generate list of n items using function
pure func generate(n: int, f: int -> Tile) -> [Tile] {
    match n {
        0 => [],
        _ => f(n - 1) :: generate(n - 1, f)
    }
}

-- Helper: build draw commands from tiles (tileSize=8 inlined due to AILANG scoping)
pure func tilesToDraw(tiles: [Tile], width: int, idx: int) -> [DrawCmd] {
    match tiles {
        [] => [],
        t :: rest => {
            let x = idx % width;
            let y = idx / width;
            let cmd = Rect(intToFloat(x * 8), intToFloat(y * 8), 8.0, 8.0, t.biome, 0);
            cmd :: tilesToDraw(rest, width, idx + 1)
        }
    }
}

-- Helper: build draw commands for NPCs (TVar2 list pattern fix v0.5.0)
pure func npcsToDraw(npcs: [NPC]) -> [DrawCmd] {
    match npcs {
        [] => [],
        npc :: rest => {
            let cmd = Rect(intToFloat(npc.pos.x * 8), intToFloat(npc.pos.y * 8), 8.0, 8.0, 10 + npc.id, 2);
            cmd :: npcsToDraw(rest)
        }
    }
}

-- Helper: build draw command for selection highlight
pure func selectionToDraw(sel: Selection) -> [DrawCmd] {
    match sel {
        SelectionNone => [],
        SelectionTile(x, y) => [Rect(intToFloat(x * 8), intToFloat(y * 8), 8.0, 8.0, 4, 3)]
    }
}

-- Helper: concatenate two lists of draw commands
pure func concatDrawCmds(a: [DrawCmd], b: [DrawCmd]) -> [DrawCmd] {
    match a {
        [] => b,
        x :: rest => x :: concatDrawCmds(rest, b)
    }
}

-- =============================================================================
-- Galaxy Map Rendering
-- =============================================================================

-- Convert star 3D position to 2D screen position (simple top-down view)
-- Center: 320, 240 (assuming 640x480), scale: 20 pixels per light-year
pure func starToScreen(pos: Vec3) -> (float, float) {
    let centerX = 320.0;
    let centerY = 240.0;
    let scale = 20.0;
    -- Top-down view: X → screen X, Y → screen Y (ignore Z for now)
    (centerX + pos.x * scale, centerY + pos.y * scale)
}

-- Calculate star radius based on luminosity (brighter = larger)
pure func starRadius(luminosity: float) -> float {
    -- Clamp between 2 and 8 pixels based on log of luminosity
    -- Sol (1.0) = 4 pixels, Sirius (25) = 6 pixels, dim M-dwarfs = 2 pixels
    let logLum = match luminosity > 0.0 {
        true => match luminosity > 100.0 {
            true => 4.0,   -- Very bright stars capped
            false => match luminosity > 1.0 {
                true => 3.0 + luminosity / 50.0,
                false => 2.0 + luminosity * 2.0
            }
        },
        false => 2.0
    };
    logLum
}

-- Render a single star as a CircleRGBA
pure func renderStar(star: Star) -> DrawCmd {
    let pos = starToScreen(star.pos);
    let radius = starRadius(star.luminosity);
    let color = spectralColor(star.spectral);
    match pos {
        (sx, sy) => CircleRGBA(sx, sy, radius, color, true, 5)
    }
}

-- Render all stars in the catalog
pure func renderStars(stars: [Star]) -> [DrawCmd] {
    match stars {
        [] => [],
        s :: rest => renderStar(s) :: renderStars(rest)
    }
}

-- Render the galaxy map view
pure func renderGalaxyMap(catalog: StarCatalog) -> [DrawCmd] {
    -- Background rectangle (dark blue)
    let bg = Rect(0.0, 0.0, 640.0, 480.0, 1052688, 0);
    -- Title
    let title = Text("Galaxy Map - Local Stars", 200.0, 20.0, 16, 16777215, 10);
    -- Sol marker label
    let solLabel = Text("Sol", 325.0, 245.0, 12, 16777215, 10);
    -- Draw stars
    let starCmds = renderStars(catalog.stars);
    bg :: title :: solLabel :: concatDrawCmds(starCmds, [])
}

-- Process click to update selection (tileSize=8 inlined, TVar2 fix v0.5.0)
pure func processSelection(input: FrameInput, world: World) -> Selection {
    if input.clickedThisFrame then {
        let tileX = floatToInt(input.worldMouseX / 8.0);
        let tileY = floatToInt(input.worldMouseY / 8.0);
        if tileX >= 0 && tileX < world.planet.width && tileY >= 0 && tileY < world.planet.height then
            SelectionTile(tileX, tileY)
        else
            SelectionNone
    } else
        world.selection
}

-- Initialize world with seed
export func init_world(seed: int) -> World {
    let w = 8;
    let h = 8;
    -- Create tiles with varied biomes based on position
    let tiles = generate(w * h, \i. { biome: i % 4 });
    -- Create test NPCs with movement patterns (using O(1) array)
    let patrolPath = #[East, East, South, South, West, West, North, North];
    let testNpcs = [
        { id: 1, pos: { x: 2, y: 2 }, pattern: PatternRandomWalk(30), moveCounter: 30, patrolIndex: 0 },
        { id: 2, pos: { x: 5, y: 3 }, pattern: PatternRandomWalk(45), moveCounter: 45, patrolIndex: 0 },
        { id: 3, pos: { x: 4, y: 4 }, pattern: PatternStatic, moveCounter: 0, patrolIndex: 0 },
        { id: 4, pos: { x: 1, y: 1 }, pattern: PatternPatrol(patrolPath), moveCounter: 0, patrolIndex: 0 }
    ];
    -- Initialize star catalog with 21 local stars (Sol + 20 nearest)
    let catalog = initLocalCatalog();
    {
        tick: 0,
        planet: { width: w, height: h, tiles: tiles },
        npcs: testNpcs,
        selection: SelectionNone,
        bridge: initBridge(),
        viewMode: ViewBridge,
        starCatalog: catalog
    }
}

-- Render based on view mode
pure func renderForView(world: World) -> [DrawCmd] {
    match world.viewMode {
        ViewBridge => renderBridge(world.bridge),
        ViewPlanet => {
            let tileCmds = tilesToDraw(world.planet.tiles, world.planet.width, 0);
            let npcCmds = npcsToDraw(world.npcs);
            let selCmds = selectionToDraw(world.selection);
            concatDrawCmds(concatDrawCmds(tileCmds, npcCmds), selCmds)
        },
        ViewGalaxyMap => renderGalaxyMap(world.starCatalog)
    }
}

-- Helper: update world for bridge view
pure func updateBridgeView(world: World, newTick: int) -> World {
    let updatedBridge = stepBridge(world.bridge, newTick);
    { world | tick: newTick, bridge: updatedBridge }
}

-- Helper: update world for planet view
func updatePlanetView(world: World, input: FrameInput, newTick: int) -> World ! {Rand} {
    let newSelection = processSelection(input, world);
    let updatedNpcs = updateAllNPCs(world.npcs, world.planet.width, world.planet.height);
    { world | tick: newTick, npcs: updatedNpcs, selection: newSelection }
}

-- Helper: update world for galaxy map view
pure func updateGalaxyView(world: World, newTick: int) -> World {
    { world | tick: newTick }
}

-- Step function: update world and produce draw commands
-- Uses Rand for NPC movement (v0.5.0)
export func step(world: World, input: FrameInput) -> (World, FrameOutput) ! {Rand} {
    let newTick = world.tick + 1;

    -- Update based on view mode (using helper functions to avoid syntax issues)
    let newWorld = match world.viewMode {
        ViewBridge => updateBridgeView(world, newTick),
        ViewPlanet => updatePlanetView(world, input, newTick),
        ViewGalaxyMap => updateGalaxyView(world, newTick)
    };

    -- Render for current view mode
    let drawCmds = renderForView(newWorld);

    let cam = { x: 0.0, y: 0.0, zoom: 1.0 };
    let output = { draw: drawCmds, sounds: [], debug: [], camera: cam };
    (newWorld, output)
}
