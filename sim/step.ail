module sim/step

-- Import types from protocol and world modules (imports fixed in v0.4.9)
import sim/protocol (FrameInput, FrameOutput, DrawCmd, Rect, Coord, PlayerAction, ActionNone, Camera)
import sim/world (World, PlanetState, Tile, Selection, SelectionNone, SelectionTile, ViewMode, ViewBridge, ViewPlanet, ViewGalaxyMap)
import sim/npc_ai (NPC, PatternStatic, PatternRandomWalk, PatternPatrol, Direction, North, South, East, West, updateAllNPCs)
import sim/bridge (BridgeState, initBridge, renderBridge, stepBridge)

-- Import effects (v0.5.0)
import std/rand (rand_int)

-- Helper: generate list of n items using function
pure func generate(n: int, f: int -> Tile) -> [Tile] {
    match n {
        0 => [],
        _ => f(n - 1) :: generate(n - 1, f)
    }
}

-- Helper: build draw commands from tiles (tileSize=8 inlined due to AILANG scoping)
pure func tilesToDraw(tiles: [Tile], width: int, idx: int) -> [DrawCmd] {
    match tiles {
        [] => [],
        t :: rest => {
            let x = idx % width;
            let y = idx / width;
            let cmd = Rect(intToFloat(x * 8), intToFloat(y * 8), 8.0, 8.0, t.biome, 0);
            cmd :: tilesToDraw(rest, width, idx + 1)
        }
    }
}

-- Helper: build draw commands for NPCs (TVar2 list pattern fix v0.5.0)
pure func npcsToDraw(npcs: [NPC]) -> [DrawCmd] {
    match npcs {
        [] => [],
        npc :: rest => {
            let cmd = Rect(intToFloat(npc.pos.x * 8), intToFloat(npc.pos.y * 8), 8.0, 8.0, 10 + npc.id, 2);
            cmd :: npcsToDraw(rest)
        }
    }
}

-- Helper: build draw command for selection highlight
pure func selectionToDraw(sel: Selection) -> [DrawCmd] {
    match sel {
        SelectionNone => [],
        SelectionTile(x, y) => [Rect(intToFloat(x * 8), intToFloat(y * 8), 8.0, 8.0, 4, 3)]
    }
}

-- Helper: concatenate two lists of draw commands
pure func concatDrawCmds(a: [DrawCmd], b: [DrawCmd]) -> [DrawCmd] {
    match a {
        [] => b,
        x :: rest => x :: concatDrawCmds(rest, b)
    }
}

-- Process click to update selection (tileSize=8 inlined, TVar2 fix v0.5.0)
pure func processSelection(input: FrameInput, world: World) -> Selection {
    if input.clickedThisFrame then {
        let tileX = floatToInt(input.worldMouseX / 8.0);
        let tileY = floatToInt(input.worldMouseY / 8.0);
        if tileX >= 0 && tileX < world.planet.width && tileY >= 0 && tileY < world.planet.height then
            SelectionTile(tileX, tileY)
        else
            SelectionNone
    } else
        world.selection
}

-- Initialize world with seed
export func init_world(seed: int) -> World {
    let w = 8;
    let h = 8;
    -- Create tiles with varied biomes based on position
    let tiles = generate(w * h, \i. { biome: i % 4 });
    -- Create test NPCs with movement patterns (using O(1) array)
    let patrolPath = #[East, East, South, South, West, West, North, North];
    let testNpcs = [
        { id: 1, pos: { x: 2, y: 2 }, pattern: PatternRandomWalk(30), moveCounter: 30, patrolIndex: 0 },
        { id: 2, pos: { x: 5, y: 3 }, pattern: PatternRandomWalk(45), moveCounter: 45, patrolIndex: 0 },
        { id: 3, pos: { x: 4, y: 4 }, pattern: PatternStatic, moveCounter: 0, patrolIndex: 0 },
        { id: 4, pos: { x: 1, y: 1 }, pattern: PatternPatrol(patrolPath), moveCounter: 0, patrolIndex: 0 }
    ];
    {
        tick: 0,
        planet: { width: w, height: h, tiles: tiles },
        npcs: testNpcs,
        selection: SelectionNone,
        bridge: initBridge(),
        viewMode: ViewBridge
    }
}

-- Render based on view mode
pure func renderForView(world: World) -> [DrawCmd] {
    match world.viewMode {
        ViewBridge => renderBridge(world.bridge),
        ViewPlanet => {
            let tileCmds = tilesToDraw(world.planet.tiles, world.planet.width, 0);
            let npcCmds = npcsToDraw(world.npcs);
            let selCmds = selectionToDraw(world.selection);
            concatDrawCmds(concatDrawCmds(tileCmds, npcCmds), selCmds)
        },
        ViewGalaxyMap => []
    }
}

-- Helper: update world for bridge view
pure func updateBridgeView(world: World, newTick: int) -> World {
    let updatedBridge = stepBridge(world.bridge, newTick);
    { world | tick: newTick, bridge: updatedBridge }
}

-- Helper: update world for planet view
func updatePlanetView(world: World, input: FrameInput, newTick: int) -> World ! {Rand} {
    let newSelection = processSelection(input, world);
    let updatedNpcs = updateAllNPCs(world.npcs, world.planet.width, world.planet.height);
    { world | tick: newTick, npcs: updatedNpcs, selection: newSelection }
}

-- Helper: update world for galaxy map view
pure func updateGalaxyView(world: World, newTick: int) -> World {
    { world | tick: newTick }
}

-- Step function: update world and produce draw commands
-- Uses Rand for NPC movement (v0.5.0)
export func step(world: World, input: FrameInput) -> (World, FrameOutput) ! {Rand} {
    let newTick = world.tick + 1;

    -- Update based on view mode (using helper functions to avoid syntax issues)
    let newWorld = match world.viewMode {
        ViewBridge => updateBridgeView(world, newTick),
        ViewPlanet => updatePlanetView(world, input, newTick),
        ViewGalaxyMap => updateGalaxyView(world, newTick)
    };

    -- Render for current view mode
    let drawCmds = renderForView(newWorld);

    let cam = { x: 0.0, y: 0.0, zoom: 1.0 };
    let output = { draw: drawCmds, sounds: [], debug: [], camera: cam };
    (newWorld, output)
}
