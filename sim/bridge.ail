module sim/bridge

-- =============================================================================
-- Bridge Interior Types
-- The bridge is the command center of the ship - the player's primary interface
-- =============================================================================

import sim/protocol (Coord, DrawCmd, IsoTile, IsoEntity, FrameInput, KeyEvent, Rect, Sprite, Line, RectRGBA, Circle, CircleRGBA, Text, GalaxyBg, SpaceBg, Planets3D, BubbleArc)
import sim/npc_ai (Direction, North, South, East, West)
import std/option (Option, Some, None)
import std/list (concat)
import std/math (sin, cos, PI)

-- =============================================================================
-- Color Constants (RGBA as decimal integers)
-- =============================================================================

-- Floor colors
pure func colorFloor() -> int { 707406591 }         -- #2A3F4FFF - Blue-gray floor
pure func colorFloorGlow() -> int { 858993919 }     -- #333F4FFF - Slightly glowing
pure func colorDomeEdge() -> int { 439041279 }      -- #1A2F3FFF - Darker edge
pure func colorWalkway() -> int { 1145324799 }      -- #445566FF - Walkway highlight
pure func colorCaptainArea() -> int { 606348543 }   -- #242A30FF - Captain area
pure func colorWall() -> int { 252645631 }          -- #0F0F0FFF - Almost black (void)

-- Console colors
pure func colorHelm() -> int { 4120593151 }         -- #F5A623FF - Amber/orange
pure func colorComms() -> int { 14540799 }          -- #00D9FFFF - Cyan
pure func colorStatus() -> int { 2566914303 }       -- #99CC33FF - Green
pure func colorNav() -> int { 4294935039 }          -- #FF4757FF - Red-pink
pure func colorScience() -> int { 16744447 }        -- #00FF88FF - Bright green
pure func colorCaptain() -> int { 4294940415 }      -- #FFCC00FF - Gold

-- Crew colors (by role)
pure func colorCrewPilot() -> int { 4120593151 }    -- Matches helm (amber)
pure func colorCrewComms() -> int { 14540799 }      -- Matches comms (cyan)
pure func colorCrewEngineer() -> int { 2566914303 } -- Matches status (green)
pure func colorCrewScientist() -> int { 16744447 }  -- Matches science (bright green)
pure func colorCrewCaptain() -> int { 4294940415 }  -- Matches captain (gold)
pure func colorPlayer() -> int { 65280 }            -- #00FF00FF - Pure green

-- =============================================================================
-- Bridge Station Types
-- =============================================================================

-- Crew stations on the bridge
export type BridgeStation =
    | StationHelm       -- Pilot controls
    | StationComms      -- Communications
    | StationStatus     -- Ship systems overview
    | StationNav        -- Galaxy map terminal
    | StationScience    -- Sensors and research
    | StationCaptain    -- Captain's chair
    | StationNone       -- Not at a station (moving/idle)

-- Crew ID for identifying crew members
export type CrewID = { id: int, name: string }

-- Crew activity state
export type CrewActivity =
    | ActivityIdle
    | ActivityWorking
    | ActivityTalking(CrewID)  -- Talking to another crew member

-- Crew position on the bridge
export type CrewPosition = {
    crew: CrewID,
    station: BridgeStation,
    pos: Coord,
    facing: Direction,
    activity: CrewActivity
}

-- =============================================================================
-- Console Types
-- =============================================================================

-- Console state (interactive station)
export type ConsoleState = {
    station: BridgeStation,
    pos: Coord,
    active: bool,        -- Console is powered on
    hasAlert: bool,      -- Has pending notification
    spriteId: int        -- Sprite to render
}

-- Interactable ID for hover/click detection
export type InteractableID =
    | InteractConsole(BridgeStation)
    | InteractCrew(CrewID)
    | InteractHatch(int)  -- Deck number to transition to

-- =============================================================================
-- Observation Dome
-- =============================================================================

-- State for the observation dome (shows space exterior)
export type DomeViewState = {
    targetPlanetId: int,    -- Which planet is visible (0 = none)
    shipVelocity: float,    -- Current velocity for SR effects
    viewAngle: float        -- Camera angle in radians
}

-- Create default dome view state (helper to avoid nested record literal bug)
export pure func makeDomeViewState(planetId: int, velocity: float, angle: float) -> DomeViewState {
    { targetPlanetId: planetId, shipVelocity: velocity, viewAngle: angle }
}

-- =============================================================================
-- Full Dome State (AILANG-owned cruise animation)
-- This replaces the Go dome_renderer state management
-- =============================================================================

-- Extended DomeState for full dome simulation
export type DomeState = {
    cruiseTime: float,        -- Current time in cruise animation (seconds)
    cruiseDuration: float,    -- Total journey duration (seconds)
    cruiseVelocity: float,    -- Ship velocity (0.0-0.99c)
    cameraZ: float,           -- Camera position along cruise path
    targetPlanet: int         -- Which planet we're approaching (index 0-4)
}

-- Planet data for flyby rendering
export type Planet = {
    name: string,
    colorRGBA: int,           -- Packed RGBA color
    distance: float,          -- Distance along cruise path from start
    radius: float,            -- Visual radius (scaled by perspective)
    yOffset: float            -- Vertical offset above cruise path
}

-- Initialize dome state for cruise animation
export pure func initDomeState() -> DomeState {
    {
        cruiseTime: 0.0,
        cruiseDuration: 60.0,   -- 60 second cruise loop
        cruiseVelocity: 0.15,   -- 15% speed of light
        cameraZ: 10.0,          -- Start 10 units from first planet
        targetPlanet: 4         -- Approaching Earth (index 4)
    }
}

-- Step the dome state forward (called each frame with delta time)
export pure func stepDome(state: DomeState, dt: float) -> DomeState {
    let newTime = state.cruiseTime + dt;
    -- Loop the cruise animation
    let loopedTime = if newTime > state.cruiseDuration then 0.0 else newTime;

    -- Calculate progress (0.0 to 1.0)
    let progress = loopedTime / state.cruiseDuration;
    -- Smooth step easing: 3t² - 2t³
    let eased = progress * progress * (3.0 - 2.0 * progress);

    -- Camera moves from z=10 to z=-155 along cruise path
    let startZ = 10.0;
    let endZ = 0.0 - 155.0;
    let newCamZ = startZ - (startZ - endZ) * eased;

    {
        cruiseTime: loopedTime,
        cruiseDuration: state.cruiseDuration,
        cruiseVelocity: state.cruiseVelocity,
        cameraZ: newCamZ,
        targetPlanet: state.targetPlanet
    }
}

-- Get list of planets along the cruise path (outer to inner solar system)
export pure func getPlanets() -> [Planet] {
    [
        { name: "Neptune", colorRGBA: 1350665471, distance: 15.0,  radius: 20.0, yOffset: 2.25 },
        { name: "Saturn",  colorRGBA: 3535748351, distance: 50.0,  radius: 36.0, yOffset: 7.5 },
        { name: "Jupiter", colorRGBA: 3702191359, distance: 90.0,  radius: 44.0, yOffset: 13.5 },
        { name: "Mars",    colorRGBA: 3361734911, distance: 130.0, radius: 10.0, yOffset: 19.5 },
        { name: "Earth",   colorRGBA: 1014743295, distance: 150.0, radius: 14.0, yOffset: 22.5 }
    ]
}

-- Calculate velocity from dome state (for SR effects wiring)
export pure func getDomeVelocity(state: DomeState) -> float {
    state.cruiseVelocity
}

-- Calculate cruise progress (0.0 to 1.0)
export pure func getDomeProgress(state: DomeState) -> float {
    state.cruiseTime / state.cruiseDuration
}

-- =============================================================================
-- Dome Planet Rendering (AILANG-owned)
-- Renders planets as circles with perspective projection
-- =============================================================================

-- Layer for dome rendering (behind floor, behind struts)
pure func layerDome() -> int { 0 - 10 }

-- Render a single planet with perspective projection
-- Returns empty list if planet is behind camera or too small
-- Planets render in the DOME area (top of screen, above the floor)
pure func renderPlanet(planet: Planet, cameraZ: float, scrW: float, scrH: float) -> [DrawCmd] {
    let relZ = planet.distance + cameraZ;  -- Distance from camera
    if relZ <= 0.5 then
        []  -- Behind or too close to camera
    else {
        -- Simple perspective: scale = focalLength / distance
        let scale = 100.0 / relZ;

        -- Screen position: centered horizontally
        let screenX = scrW / 2.0;

        -- Y position: start at top of dome area (y=200), offset based on yOffset
        -- Dome is upper 40% of screen (0 to ~380), floor is lower 60%
        let baseY = 200.0;  -- High in the dome area
        let screenY = baseY + planet.yOffset * scale * 5.0;

        -- Visible radius scales with distance
        let visibleRadius = planet.radius * scale;

        if visibleRadius < 1.0 then
            []  -- Too small to see
        else
            [CircleRGBA(screenX, screenY, visibleRadius, planet.colorRGBA, true, layerDome())]
    }
}

-- Recursively render all planets
pure func renderPlanetsRec(planets: [Planet], cameraZ: float, scrW: float, scrH: float) -> [DrawCmd] {
    match planets {
        [] => [],
        p :: rest => concat(
            renderPlanet(p, cameraZ, scrW, scrH),
            renderPlanetsRec(rest, cameraZ, scrW, scrH)
        )
    }
}

-- Render all planets in the dome view
export pure func renderDomePlanets(state: DomeState) -> [DrawCmd] {
    let scrW = screenWidth();
    let scrH = screenHeight();
    renderPlanetsRec(getPlanets(), state.cameraZ, scrW, scrH)
}

-- Layer for dome background (furthest back)
pure func layerDomeBg() -> int { 0 - 20 }

-- Render dome view with all 3D elements
-- AILANG controls WHEN each 3D layer renders via DrawCmd z-ordering
-- Go engine interprets these commands and calls dome_renderer methods
-- NOTE: Planets are now rendered via celestial.ail's renderSolarSystem() in step.ail
export pure func renderDome(state: DomeState) -> [DrawCmd] {
    -- Layer 1: Space background (starfield + galaxy) - furthest back
    -- Layer 2: Planets rendered by AILANG via renderSolarSystem() in step.ail
    -- Layer 3: Bubble arc (dome edge effect) - on top
    [
        SpaceBg(layerDomeBg()),           -- Starfield at z=-20
        -- Planets3D removed - now rendered by celestial.ail
        BubbleArc(layerBubbleArc3D())     -- Bubble arc at z=5 (topmost)
    ]
}

-- =============================================================================
-- Bridge State
-- =============================================================================

-- Player movement state
export type MoveState =
    | MoveIdle
    | MoveWalking(Direction)
    | MoveTransitioning(int, Coord)  -- Transitioning to deck, target position

-- Complete bridge state
export type BridgeState = {
    -- Player
    playerPos: Coord,
    playerFacing: Direction,
    moveState: MoveState,

    -- Camera (follows player, used for viewport)
    cameraX: int,
    cameraY: int,

    -- Crew
    crewPositions: [CrewPosition],

    -- Consoles
    consoles: [ConsoleState],

    -- Interaction
    hoveredInteractable: Option[InteractableID],
    selectedInteractable: Option[InteractableID],

    -- Dome (legacy - for engine compatibility)
    domeView: DomeViewState,

    -- Full Dome State (AILANG-owned cruise animation)
    domeState: DomeState,

    -- Animation tick (for frame counting)
    tick: int,

    -- Disc configuration (procedural - no stored layout)
    discRadius: int,        -- Radius of the walkable disc
    discCenterX: int,       -- Center X of disc
    discCenterY: int        -- Center Y of disc
}

-- =============================================================================
-- Bridge Input Result
-- =============================================================================

-- Result of processing bridge input
export type BridgeInputResult =
    | BridgeStay(BridgeState)              -- Stay on bridge with updated state
    | BridgeToGalaxyMap                     -- Transition to galaxy map
    | BridgeToDialogue(CrewID)              -- Start dialogue with crew
    | BridgeToDeck(int, Coord)              -- Transition to another deck

-- =============================================================================
-- Dome Struts (Structural supports with parallax)
-- Struts are rendered as lines forming an arc around the dome viewport
-- =============================================================================

-- Strut configuration
export type Strut = {
    x1: float, y1: float,      -- Start position (screen coords)
    x2: float, y2: float,      -- End position (screen coords)
    parallax: float,           -- Parallax depth (0=fixed with stars, 1=fixed with bridge)
    color: int                 -- RGBA color
}

-- Screen dimensions for strut positioning
pure func screenWidth() -> float { 1280.0 }
pure func screenHeight() -> float { 960.0 }

-- Strut visual constants
pure func strutColor() -> int { 1275068520 }      -- Dark metallic blue (0x4C5A6878 RGBA)
pure func strutHighlight() -> int { 1887670408 }  -- Lighter highlight (0x708090FF RGBA)
pure func layerStruts() -> int { -1 }             -- Behind floor (negative z)

-- Number of struts on each side of dome
pure func strutCount() -> int { 8 }

-- Arc parameters: struts form curve from sides toward top
-- Arc center Y is below screen, struts curve upward
pure func arcCenterY() -> float { 1600.0 }   -- Below screen (960 height), pushed down to match floor at 750
pure func arcRadius() -> float { 900.0 }     -- Large radius for gentle curve

-- Calculate strut base position on arc (bottom attachment point)
-- Index 0 = leftmost, strutCount-1 = rightmost
pure func strutBaseX(index: int, total: int) -> float {
    let centerX = screenWidth() / 2.0;
    -- Spread struts across lower portion of arc (roughly -60° to +60°)
    let angleRange = PI() / 3.0;  -- 60 degrees each side
    let angleStep = (angleRange * 2.0) / intToFloat(total - 1);
    let angle = (0.0 - angleRange) + intToFloat(index) * angleStep;
    centerX + arcRadius() * sin(angle)
}

pure func strutBaseY(index: int, total: int) -> float {
    let angleRange = PI() / 3.0;
    let angleStep = (angleRange * 2.0) / intToFloat(total - 1);
    let angle = (0.0 - angleRange) + intToFloat(index) * angleStep;
    arcCenterY() - arcRadius() * cos(angle)
}

-- Strut top position (extends toward screen edge/top)
pure func strutTopX(index: int, total: int) -> float {
    let baseX = strutBaseX(index, total);
    let centerX = screenWidth() / 2.0;
    -- Extend outward from center
    let dx = baseX - centerX;
    baseX + dx * 0.3
}

pure func strutTopY(index: int, total: int) -> float {
    let baseY = strutBaseY(index, total);
    -- Extend upward (toward top of screen)
    baseY - 150.0
}

-- Calculate parallax offset for strut tops based on camera position
-- Creates subtle sway as ship cruises through space
pure func strutParallax(index: int, total: int, cameraZ: float) -> float {
    -- Parallax varies by strut position (left struts move opposite to right)
    let centerIndex = intToFloat(total - 1) / 2.0;
    let offsetFromCenter = intToFloat(index) - centerIndex;
    -- Map cameraZ (10 to -155) to parallax offset (-5 to 5 pixels per strut)
    let progress = (10.0 - cameraZ) / 165.0;
    offsetFromCenter * progress * 3.0
}

-- Render a single strut as a Line with parallax
pure func renderStrutWithParallax(index: int, total: int, cameraZ: float) -> DrawCmd {
    let parallax = strutParallax(index, total, cameraZ);
    Line(
        strutBaseX(index, total),
        strutBaseY(index, total),
        strutTopX(index, total) + parallax,  -- Top sways with parallax
        strutTopY(index, total),
        strutColor(),
        2.0,
        layerStruts()
    )
}

-- Render struts recursively with parallax
pure func renderStrutsRec(index: int, total: int, cameraZ: float) -> [DrawCmd] {
    if index >= total then
        []
    else
        renderStrutWithParallax(index, total, cameraZ) :: renderStrutsRec(index + 1, total, cameraZ)
}

-- Render all dome struts with parallax from dome state
export pure func renderStruts(state: BridgeState) -> [DrawCmd] {
    renderStrutsRec(0, strutCount(), state.domeState.cameraZ)
}

-- =============================================================================
-- Tile IDs (Bridge-specific sprites)
-- =============================================================================

-- Bridge tile sprite IDs (1000-1099 range)
export pure func tileFloor() -> int { 1000 }
export pure func tileFloorGlow() -> int { 1001 }
export pure func tileConsoleBase() -> int { 1002 }
export pure func tileWalkway() -> int { 1003 }
export pure func tileDomeEdge() -> int { 1004 }
export pure func tileWall() -> int { 1005 }
export pure func tileHatch() -> int { 1006 }
export pure func tileCaptainArea() -> int { 1007 }

-- Console sprite IDs (1100-1149 range)
export pure func spriteConsoleHelm() -> int { 1100 }
export pure func spriteConsoleComms() -> int { 1101 }
export pure func spriteConsoleStatus() -> int { 1102 }
export pure func spriteConsoleNav() -> int { 1103 }
export pure func spriteConsoleScience() -> int { 1104 }
export pure func spriteConsoleCaptain() -> int { 1105 }

-- Crew sprite IDs (1200-1249 range)
export pure func spriteCrewPilot() -> int { 1200 }
export pure func spriteCrewComms() -> int { 1201 }
export pure func spriteCrewEngineer() -> int { 1202 }
export pure func spriteCrewScientist() -> int { 1203 }
export pure func spriteCrewCaptain() -> int { 1204 }
export pure func spritePlayer() -> int { 1205 }

-- =============================================================================
-- Helper Functions
-- =============================================================================

-- Helper to construct Coord
pure func makeCoord(x: int, y: int) -> Coord {
    { x: x, y: y }
}

-- Distance squared from disc center (efficient - no sqrt needed)
pure func distSq(x: int, y: int, cx: int, cy: int) -> int {
    let dx = x - cx;
    let dy = y - cy;
    dx * dx + dy * dy
}

-- Check if a position is within the disc
export pure func isOnDisc(x: int, y: int, cx: int, cy: int, radius: int) -> bool {
    distSq(x, y, cx, cy) <= radius * radius
}

-- Check if a tile is walkable (procedural based on disc)
-- Uses squared distance to avoid expensive isqrt
export pure func isWalkable(state: BridgeState, x: int, y: int) -> bool {
    let dSq = distSq(x, y, state.discCenterX, state.discCenterY);
    let radiusSq = state.discRadius * state.discRadius;
    -- Walkable if within disc radius minus 1 (edge is not walkable)
    dSq < radiusSq
}

-- Get procedural tile type based on position on disc
-- Uses squared distances to avoid expensive isqrt (major perf win)
export pure func getTileType(x: int, y: int, cx: int, cy: int, radius: int) -> int {
    let dSq = distSq(x, y, cx, cy);
    let radiusSq = radius * radius;
    let edgeSq = (radius - 1) * (radius - 1);
    if dSq >= radiusSq then
        tileWall()          -- Outside disc = void
    else if dSq >= edgeSq then
        tileDomeEdge()      -- Edge of disc
    else if dSq <= 9 then
        tileCaptainArea()   -- Center = captain's area (d <= 3)
    else if dSq <= 36 then
        tileFloorGlow()     -- Inner ring = glowing floor (d <= 6)
    else if (x + y) % 8 == 0 then
        tileWalkway()       -- Radial walkways
    else
        tileFloor()         -- Normal floor
}

-- Viewport size (tiles visible in each direction from camera)
export pure func viewportSize() -> int { 10 }

-- Get sprite ID for a station
export pure func stationSprite(station: BridgeStation) -> int {
    match station {
        StationHelm => spriteConsoleHelm(),
        StationComms => spriteConsoleComms(),
        StationStatus => spriteConsoleStatus(),
        StationNav => spriteConsoleNav(),
        StationScience => spriteConsoleScience(),
        StationCaptain => spriteConsoleCaptain(),
        StationNone => 0
    }
}

-- Get sprite ID for a crew member based on their station
export pure func crewSprite(station: BridgeStation) -> int {
    match station {
        StationHelm => spriteCrewPilot(),
        StationComms => spriteCrewComms(),
        StationStatus => spriteCrewEngineer(),
        StationScience => spriteCrewScientist(),
        StationCaptain => spriteCrewCaptain(),
        StationNav => spriteCrewEngineer(),  -- Nav officer uses engineer sprite for now
        StationNone => spriteCrewPilot()     -- Default
    }
}

-- Move coordinate in direction
export pure func moveInDirection(pos: Coord, dir: Direction) -> Coord {
    let px = pos.x;
    let py = pos.y;
    match dir {
        North => makeCoord(px, py - 1),
        South => makeCoord(px, py + 1),
        East => makeCoord(px + 1, py),
        West => makeCoord(px - 1, py)
    }
}

-- =============================================================================
-- Console and Crew Definitions for Large Disc
-- =============================================================================

-- Disc configuration constants for 48x48 disc (radius 24, center 24,24)
export pure func discRadiusDefault() -> int { 24 }
export pure func discCenterDefault() -> int { 24 }

-- Create console state list - positioned around the large disc
-- Consoles are placed at various radii from center
export pure func createConsoles() -> [ConsoleState] {
    let cx = discCenterDefault();
    let cy = discCenterDefault();
    [
        -- Front consoles (toward "forward" of ship, y < center)
        { station: StationHelm, pos: makeCoord(cx, cy - 10), active: true, hasAlert: false, spriteId: spriteConsoleHelm() },
        { station: StationComms, pos: makeCoord(cx - 8, cy - 8), active: true, hasAlert: false, spriteId: spriteConsoleComms() },
        { station: StationStatus, pos: makeCoord(cx + 8, cy - 8), active: true, hasAlert: false, spriteId: spriteConsoleStatus() },
        -- Captain's chair at center
        { station: StationCaptain, pos: makeCoord(cx, cy), active: true, hasAlert: false, spriteId: spriteConsoleCaptain() },
        -- Side consoles (equatorial)
        { station: StationNav, pos: makeCoord(cx - 12, cy), active: true, hasAlert: false, spriteId: spriteConsoleNav() },
        { station: StationScience, pos: makeCoord(cx + 12, cy), active: true, hasAlert: false, spriteId: spriteConsoleScience() }
    ]
}

-- Create default crew positions - crew stand near their stations
export pure func createDefaultCrew() -> [CrewPosition] {
    let cx = discCenterDefault();
    let cy = discCenterDefault();
    [
        {
            crew: { id: 1, name: "Pilot Chen" },
            station: StationHelm,
            pos: makeCoord(cx, cy - 9),
            facing: North,
            activity: ActivityWorking
        },
        {
            crew: { id: 2, name: "Comms Officer Patel" },
            station: StationComms,
            pos: makeCoord(cx - 8, cy - 7),
            facing: North,
            activity: ActivityWorking
        },
        {
            crew: { id: 3, name: "Engineer Torres" },
            station: StationStatus,
            pos: makeCoord(cx + 8, cy - 7),
            facing: North,
            activity: ActivityWorking
        },
        {
            crew: { id: 4, name: "Navigator Kim" },
            station: StationNav,
            pos: makeCoord(cx - 11, cy),
            facing: East,
            activity: ActivityWorking
        },
        {
            crew: { id: 5, name: "Science Officer Okafor" },
            station: StationScience,
            pos: makeCoord(cx + 11, cy),
            facing: West,
            activity: ActivityWorking
        },
        {
            crew: { id: 6, name: "Captain Reyes" },
            station: StationCaptain,
            pos: makeCoord(cx, cy + 1),
            facing: North,
            activity: ActivityIdle
        }
    ]
}

-- =============================================================================
-- Bridge Initialization
-- =============================================================================

-- Create initial bridge state
export pure func initBridge() -> BridgeState {
    let cx = discCenterDefault();
    let cy = discCenterDefault();
    let radius = discRadiusDefault();
    {
        -- Player starts at south edge of disc (high y value)
        playerPos: makeCoord(cx, cy + 16),
        playerFacing: North,
        moveState: MoveIdle,

        -- Camera starts centered on player
        cameraX: cx,
        cameraY: cy + 16,

        -- Load crew
        crewPositions: createDefaultCrew(),

        -- Load consoles
        consoles: createConsoles(),

        -- No current interaction
        hoveredInteractable: None,
        selectedInteractable: None,

        -- Dome showing generic space view (use helper to avoid nested record bug)
        domeView: makeDomeViewState(0, 0.15, 0.0),

        -- Full dome state with cruise animation
        domeState: initDomeState(),

        -- Animation tick
        tick: 0,

        -- Disc configuration
        discRadius: radius,
        discCenterX: cx,
        discCenterY: cy
    }
}

-- =============================================================================
-- Bridge Rendering Functions
-- =============================================================================

-- Layer constants for draw ordering
pure func layerFloor() -> int { 0 }
pure func layerConsoles() -> int { 1 }
pure func layerCrew() -> int { 2 }
pure func layerPlayer() -> int { 3 }

-- 3D rendering layer constants (AILANG controls when Tetra3D renders)
-- These layers ensure 3D elements render at correct times relative to 2D elements
pure func layerPlanets3D() -> int { 4 }   -- 3D planets render AFTER player (above floor)
pure func layerBubbleArc3D() -> int { 5 } -- Bubble arc renders on top
pure func layerUI() -> int { 100 }        -- UI renders on very top

-- Default color (white, no tint) - 0xFFFFFFFF as decimal
pure func colorWhite() -> int { 4294967295 }

-- Screen center offset for centering the isometric grid
-- Screen is 1280x960, we want the grid centered horizontally
-- and positioned in the lower portion (below the dome)
pure func screenOffsetX() -> float { 640.0 }  -- Center horizontally
pure func screenOffsetY() -> float { 750.0 }  -- Near bottom - planets fly overhead in dome area above

-- Get color for tile type (placeholder rendering)
pure func tileColor(tileType: int) -> int {
    if tileType == tileWall() then colorWall()
    else if tileType == tileDomeEdge() then colorDomeEdge()
    else if tileType == tileCaptainArea() then colorCaptainArea()
    else if tileType == tileFloorGlow() then colorFloorGlow()
    else if tileType == tileWalkway() then colorWalkway()
    else colorFloor()
}

-- Render a single floor tile at world position, relative to camera
-- Using RectRGBA for visible placeholder (isometric diamond approximated as rect)
pure func renderTileAt(worldX: int, worldY: int, camX: int, camY: int, tileType: int) -> DrawCmd {
    -- Calculate position relative to camera (so camera is at screen center)
    let relX = worldX - camX;
    let relY = worldY - camY;
    -- Isometric projection: x' = (x - y) * tileWidth/2, y' = (x + y) * tileHeight/2
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    -- Render as small rectangle representing isometric tile
    RectRGBA(screenX - 28.0, screenY - 12.0, 56.0, 28.0, tileColor(tileType), layerFloor())
}

-- Render tile row helper (recurses through x from start to maxX)
pure func renderFloorRowViewportRec(state: BridgeState, x: int, y: int, maxX: int, acc: [DrawCmd]) -> [DrawCmd] {
    if x > maxX then acc
    else renderFloorRowViewportRec(
        state,
        x + 1,
        y,
        maxX,
        renderTileAt(x, y, state.cameraX, state.cameraY,
            getTileType(x, y, state.discCenterX, state.discCenterY, state.discRadius)) :: acc
    )
}

-- Render one row of tiles in viewport
pure func renderFloorRowViewport(state: BridgeState, x: int, y: int, maxX: int) -> [DrawCmd] {
    renderFloorRowViewportRec(state, x, y, maxX, [])
}

-- Render all floor rows in viewport (procedural)
pure func renderFloorRowsViewport(state: BridgeState, y: int, maxY: int, minX: int, maxX: int) -> [DrawCmd] {
    if y > maxY then
        []
    else
        concat(
            renderFloorRowViewport(state, minX, y, maxX),
            renderFloorRowsViewport(state, y + 1, maxY, minX, maxX)
        )
}

-- Render all floor tiles within viewport around camera
export pure func renderBridgeFloor(state: BridgeState) -> [DrawCmd] {
    let vp = viewportSize();
    let minX = state.cameraX - vp;
    let maxX = state.cameraX + vp;
    let minY = state.cameraY - vp;
    let maxY = state.cameraY + vp;
    renderFloorRowsViewport(state, minY, maxY, minX, maxX)
}

-- Helper: check if world position is within viewport
pure func inViewport(wx: int, wy: int, camX: int, camY: int) -> bool {
    let vp = viewportSize();
    let dx = wx - camX;
    let dy = wy - camY;
    dx >= 0 - vp - 2 && dx <= vp + 2 && dy >= 0 - vp - 2 && dy <= vp + 2
}

-- Get color for console station
pure func consoleColor(station: BridgeStation) -> int {
    match station {
        StationHelm => colorHelm(),
        StationComms => colorComms(),
        StationStatus => colorStatus(),
        StationNav => colorNav(),
        StationScience => colorScience(),
        StationCaptain => colorCaptain(),
        StationNone => colorFloor()
    }
}

-- Get color for crew member based on their station
pure func crewColor(station: BridgeStation) -> int {
    match station {
        StationHelm => colorCrewPilot(),
        StationComms => colorCrewComms(),
        StationStatus => colorCrewEngineer(),
        StationNav => colorCrewEngineer(),      -- Nav uses engineer color
        StationScience => colorCrewScientist(),
        StationCaptain => colorCrewCaptain(),
        StationNone => colorPlayer()            -- Default
    }
}

-- Render a single console relative to camera (colored rectangle placeholder)
pure func renderConsole(console: ConsoleState, camX: int, camY: int) -> [DrawCmd] {
    let relX = console.pos.x - camX;
    let relY = console.pos.y - camY;
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    let color = consoleColor(console.station);
    -- Console as colored rectangle (elevated above floor)
    [RectRGBA(screenX - 24.0, screenY - 32.0, 48.0, 24.0, color, layerConsoles())]
}

-- Render all consoles recursively (only those in viewport)
pure func renderConsolesRec(consoles: [ConsoleState], camX: int, camY: int) -> [DrawCmd] {
    match consoles {
        [] => [],
        c :: rest =>
            if inViewport(c.pos.x, c.pos.y, camX, camY) then
                concat(renderConsole(c, camX, camY), renderConsolesRec(rest, camX, camY))
            else
                renderConsolesRec(rest, camX, camY)
    }
}

-- Render all console entities
export pure func renderConsoles(state: BridgeState) -> [DrawCmd] {
    renderConsolesRec(state.consoles, state.cameraX, state.cameraY)
}

-- Render a single crew member relative to camera (colored circle with name label)
pure func renderCrewMember(crew: CrewPosition, camX: int, camY: int) -> [DrawCmd] {
    let relX = crew.pos.x - camX;
    let relY = crew.pos.y - camY;
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    let color = crewColor(crew.station);
    -- Circle at crew position + name label below
    [
        CircleRGBA(screenX, screenY - 8.0, 12.0, color, true, layerCrew()),
        Text(crew.crew.name, screenX - 30.0, screenY + 8.0, 8, 4294967295, layerCrew() + 1)
    ]
}

-- Render all crew recursively (only those in viewport)
pure func renderCrewRec(crew: [CrewPosition], camX: int, camY: int) -> [DrawCmd] {
    match crew {
        [] => [],
        c :: rest =>
            if inViewport(c.pos.x, c.pos.y, camX, camY) then
                concat(renderCrewMember(c, camX, camY), renderCrewRec(rest, camX, camY))
            else
                renderCrewRec(rest, camX, camY)
    }
}

-- Render all crew members
export pure func renderBridgeCrew(state: BridgeState) -> [DrawCmd] {
    renderCrewRec(state.crewPositions, state.cameraX, state.cameraY)
}

-- Render the player entity (green rectangle with "YOU" label)
export pure func renderPlayer(state: BridgeState) -> [DrawCmd] {
    let relX = state.playerPos.x - state.cameraX;
    let relY = state.playerPos.y - state.cameraY;
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    -- Green rectangle (slightly larger than crew circles) with "YOU" label
    [
        RectRGBA(screenX - 10.0, screenY - 18.0, 20.0, 20.0, colorPlayer(), layerPlayer()),
        Text("YOU", screenX - 12.0, screenY + 8.0, 10, colorPlayer(), layerPlayer() + 1)
    ]
}

-- =============================================================================
-- Interaction UI Rendering
-- =============================================================================

-- Get name of a bridge station for display
pure func stationName(station: BridgeStation) -> string {
    match station {
        StationHelm => "HELM",
        StationComms => "COMMS",
        StationStatus => "STATUS",
        StationScience => "SCIENCE",
        StationWeapons => "WEAPONS"
    }
}

-- Color constants for UI (converted from hex to decimal)
pure func colorDarkBg() -> int { 540029132 }       -- 0x203040CC - Dark blue with alpha
pure func colorYellow() -> int { 4293559551 }       -- 0xFFDD44FF - Bright yellow
pure func colorPanelBg() -> int { 270545120 }       -- 0x102030E0 - Dark panel
pure func colorUIGreen() -> int { 1157595391 }      -- 0x44FF44FF - Bright green
pure func colorUIGray() -> int { 2290649343 }       -- 0x888888FF - Gray

-- Render interaction prompt when player is near a console
export pure func renderInteractionPrompt(state: BridgeState) -> [DrawCmd] {
    match state.hoveredInteractable {
        None => [],
        Some(interactable) =>
            match interactable {
                InteractConsole(station) =>
                    -- Show prompt at bottom center of screen
                    [
                        RectRGBA(480.0, 650.0, 320.0, 40.0, colorDarkBg(), layerUI()),
                        Text("Press E: Interact", 530.0, 665.0, 12, colorYellow(), layerUI() + 1)
                    ],
                InteractCrew(crew) =>
                    [
                        RectRGBA(480.0, 650.0, 320.0, 40.0, colorDarkBg(), layerUI()),
                        Text("Press E: Talk", 530.0, 665.0, 12, colorYellow(), layerUI() + 1)
                    ],
                InteractHatch(deck) =>
                    [
                        RectRGBA(480.0, 650.0, 320.0, 40.0, colorDarkBg(), layerUI()),
                        Text("Press E: Use hatch", 530.0, 665.0, 12, colorYellow(), layerUI() + 1)
                    ]
            }
    }
}

-- Render selected console panel (when interacting)
export pure func renderSelectedPanel(state: BridgeState) -> [DrawCmd] {
    match state.selectedInteractable {
        None => [],
        Some(interactable) =>
            match interactable {
                InteractConsole(station) =>
                    -- Info panel at right side of screen
                    [
                        -- Panel background
                        RectRGBA(880.0, 100.0, 360.0, 280.0, colorPanelBg(), layerUI()),
                        -- Title bar
                        RectRGBA(880.0, 100.0, 360.0, 40.0, consoleColor(station), layerUI() + 1),
                        Text(stationName(station), 1000.0, 115.0, 14, colorWhite(), layerUI() + 2),
                        -- Status
                        Text("Status: OPERATIONAL", 900.0, 170.0, 12, colorUIGreen(), layerUI() + 2),
                        -- Instructions
                        Text("Press E or ESC to close", 900.0, 340.0, 10, colorUIGray(), layerUI() + 2)
                    ],
                InteractCrew(crew) =>
                    [
                        RectRGBA(880.0, 100.0, 360.0, 280.0, colorPanelBg(), layerUI()),
                        RectRGBA(880.0, 100.0, 360.0, 40.0, colorPlayer(), layerUI() + 1),
                        Text(crew.name, 1000.0, 115.0, 14, colorWhite(), layerUI() + 2),
                        Text("Crew Member", 900.0, 170.0, 12, colorWhite(), layerUI() + 2),
                        Text("Press E or ESC to close", 900.0, 340.0, 10, colorUIGray(), layerUI() + 2)
                    ],
                InteractHatch(deck) =>
                    [
                        RectRGBA(880.0, 100.0, 360.0, 200.0, colorPanelBg(), layerUI()),
                        Text("HATCH", 1000.0, 115.0, 14, colorWhite(), layerUI() + 1),
                        Text("Press E or ESC to close", 900.0, 260.0, 10, colorUIGray(), layerUI() + 2)
                    ]
            }
    }
}

-- Render entire bridge (combines all layers)
-- Layer order: dome -> struts -> floor -> consoles -> crew -> player -> UI (front)
export pure func renderBridge(state: BridgeState) -> [DrawCmd] {
    concat(
        concat(
            concat(
                concat(
                    concat(
                        concat(
                            concat(
                                renderDome(state.domeState),  -- Dome with planets (background)
                                renderStruts(state)           -- Structural struts
                            ),
                            renderBridgeFloor(state)          -- Isometric floor tiles
                        ),
                        renderConsoles(state)                 -- Console stations
                    ),
                    renderBridgeCrew(state)                   -- Crew members
                ),
                renderPlayer(state)                           -- Player character
            ),
            renderInteractionPrompt(state)                    -- "Press E" prompt
        ),
        renderSelectedPanel(state)                            -- Selected console panel
    )
}

-- =============================================================================
-- Player Input Processing
-- =============================================================================

-- Key codes for WASD (matching Ebiten key codes)
pure func keyW() -> int { 87 }
pure func keyA() -> int { 65 }
pure func keyS() -> int { 83 }
pure func keyD() -> int { 68 }
pure func keyUp() -> int { 265 }
pure func keyDown() -> int { 264 }
pure func keyLeft() -> int { 263 }
pure func keyRight() -> int { 262 }
pure func keyE() -> int { 69 }        -- Interact key
pure func keyEscape() -> int { 256 }  -- Cancel/close key

-- Check if a key is in the key list (recursive)
pure func hasKeyRec(keyCode: int, keys: [KeyEvent]) -> bool {
    match keys {
        [] => false,
        k :: rest => if k.key == keyCode && k.kind == "pressed" then true else hasKeyRec(keyCode, rest)
    }
}

-- Check if a key is pressed this frame
pure func hasKey(keyCode: int, input: FrameInput) -> bool {
    hasKeyRec(keyCode, input.keys)
}

-- Get movement direction from input (returns None if no movement key pressed)
pure func getInputDirection(input: FrameInput) -> Option[Direction] {
    if hasKey(keyW(), input) || hasKey(keyUp(), input) then Some(North)
    else if hasKey(keyS(), input) || hasKey(keyDown(), input) then Some(South)
    else if hasKey(keyA(), input) || hasKey(keyLeft(), input) then Some(West)
    else if hasKey(keyD(), input) || hasKey(keyRight(), input) then Some(East)
    else None
}

-- Try to move player in a direction, checking walkability
pure func tryMovePlayer(state: BridgeState, dir: Direction) -> BridgeState {
    let newPos = moveInDirection(state.playerPos, dir);
    if isWalkable(state, newPos.x, newPos.y) then
        { state |
            playerPos: newPos,
            playerFacing: dir,
            moveState: MoveWalking(dir),
            cameraX: newPos.x,
            cameraY: newPos.y
        }
    else
        { state | playerFacing: dir, moveState: MoveIdle }
}

-- Helper: set player to idle
pure func setPlayerIdle(state: BridgeState) -> BridgeState {
    { state | moveState: MoveIdle }
}

-- =============================================================================
-- Console Interaction (Hover/Click)
-- =============================================================================

-- Absolute value for distance calculation
pure func absInt(x: int) -> int {
    if x < 0 then 0 - x else x
}

-- Manhattan distance between two coordinates
pure func manhattanDistance(a: Coord, b: Coord) -> int {
    absInt(a.x - b.x) + absInt(a.y - b.y)
}

-- Check if player is adjacent to a console (within 2 tiles)
pure func isNearConsole(playerPos: Coord, console: ConsoleState) -> bool {
    manhattanDistance(playerPos, console.pos) <= 2
}

-- Find nearby console (recursive search)
pure func findNearbyConsoleRec(playerPos: Coord, consoles: [ConsoleState]) -> Option[BridgeStation] {
    match consoles {
        [] => None,
        c :: rest =>
            if isNearConsole(playerPos, c) then Some(c.station)
            else findNearbyConsoleRec(playerPos, rest)
    }
}

-- Find console near player, return as InteractableID
pure func findNearbyInteractable(state: BridgeState) -> Option[InteractableID] {
    match findNearbyConsoleRec(state.playerPos, state.consoles) {
        Some(station) => Some(InteractConsole(station)),
        None => None
    }
}

-- Helper: update hovered interactable
pure func updateHover(state: BridgeState) -> BridgeState {
    { state | hoveredInteractable: findNearbyInteractable(state) }
}

-- Helper: deselect current interactable
pure func deselectInteractable(state: BridgeState) -> BridgeState {
    { state | selectedInteractable: None }
}

-- Helper: select currently hovered interactable
pure func selectHovered(state: BridgeState) -> BridgeState {
    { state | selectedInteractable: state.hoveredInteractable }
}

-- Helper: toggle selection when E is pressed
pure func toggleSelection(state: BridgeState) -> BridgeState {
    match state.selectedInteractable {
        Some(_) => deselectInteractable(state),
        None => selectHovered(state)
    }
}

-- Helper: clear selection (Escape key)
pure func clearSelection(state: BridgeState) -> BridgeState {
    { state | selectedInteractable: None }
}

-- Process player input and update state
export pure func processBridgeInput(state: BridgeState, input: FrameInput) -> BridgeState {
    -- First handle movement
    let afterMove = match getInputDirection(input) {
        Some(dir) => tryMovePlayer(state, dir),
        None => setPlayerIdle(state)
    };

    -- Update hover state based on new position
    let afterHover = updateHover(afterMove);

    -- Handle interaction keys
    if hasKey(keyEscape(), input) then clearSelection(afterHover)
    else if hasKey(keyE(), input) then toggleSelection(afterHover)
    else afterHover
}

-- =============================================================================
-- Bridge Update Logic (Step function)
-- =============================================================================

-- Get direction to move based on frame and crew ID (deterministic patrol)
pure func getPatrolDirection(crewId: int, frame: int) -> Direction {
    -- Each crew member has a different patrol pattern based on ID
    let phase = (frame / 30 + crewId * 7) % 4;
    match phase {
        0 => North,
        1 => East,
        2 => South,
        _ => West
    }
}

-- Try to move a crew member, checking walkability
pure func tryMoveCrew(crew: CrewPosition, dir: Direction, state: BridgeState) -> CrewPosition {
    let newPos = moveInDirection(crew.pos, dir);
    if isWalkable(state, newPos.x, newPos.y) then
        { crew | pos: newPos, facing: dir }
    else
        { crew | facing: dir }  -- Just turn, don't move
}

-- Update a single crew member (patrol near their station)
pure func updateCrewMember(crew: CrewPosition, frame: int, state: BridgeState) -> CrewPosition {
    -- Only move every 30 frames (about 0.5 sec at 60fps)
    if frame % 30 == 0 then tryMoveCrew(crew, getPatrolDirection(crew.crew.id, frame), state) else crew
}

-- Update all crew recursively
pure func updateCrewRec(crew: [CrewPosition], frame: int, state: BridgeState) -> [CrewPosition] {
    match crew {
        [] => [],
        c :: rest => updateCrewMember(c, frame, state) :: updateCrewRec(rest, frame, state)
    }
}

-- Step the bridge state forward (called each frame)
-- frame: current frame number (used for crew patrol timing)
export pure func stepBridge(state: BridgeState, frame: int) -> BridgeState {
    -- Delta time at 60 FPS
    let dt = 1.0 / 60.0;

    -- Step dome cruise animation
    let updatedDome = stepDome(state.domeState, dt);

    -- Update legacy domeView for engine compatibility
    let updatedDomeView = makeDomeViewState(
        updatedDome.targetPlanet,
        updatedDome.cruiseVelocity,
        state.domeView.viewAngle
    );

    -- Update crew patrol movement
    let updatedCrew = updateCrewRec(state.crewPositions, frame, state);

    -- Use record update syntax (chain updates)
    { state |
        crewPositions: updatedCrew,
        domeState: updatedDome,
        domeView: updatedDomeView,
        tick: frame
    }
}
