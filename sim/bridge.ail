module sim/bridge

-- =============================================================================
-- Bridge Interior Types
-- The bridge is the command center of the ship - the player's primary interface
-- =============================================================================

import sim/protocol (Coord, DrawCmd, IsoTile, IsoEntity, FrameInput, Rect, Sprite)
import sim/npc_ai (Direction, North, South, East, West)
import std/option (Option, Some, None)
import std/list (concat)

-- =============================================================================
-- Bridge Station Types
-- =============================================================================

-- Crew stations on the bridge
export type BridgeStation =
    | StationHelm       -- Pilot controls
    | StationComms      -- Communications
    | StationStatus     -- Ship systems overview
    | StationNav        -- Galaxy map terminal
    | StationScience    -- Sensors and research
    | StationCaptain    -- Captain's chair
    | StationNone       -- Not at a station (moving/idle)

-- Crew ID for identifying crew members
export type CrewID = { id: int, name: string }

-- Crew activity state
export type CrewActivity =
    | ActivityIdle
    | ActivityWorking
    | ActivityTalking(CrewID)  -- Talking to another crew member

-- Crew position on the bridge
export type CrewPosition = {
    crew: CrewID,
    station: BridgeStation,
    pos: Coord,
    facing: Direction,
    activity: CrewActivity
}

-- =============================================================================
-- Console Types
-- =============================================================================

-- Console state (interactive station)
export type ConsoleState = {
    station: BridgeStation,
    pos: Coord,
    active: bool,        -- Console is powered on
    hasAlert: bool,      -- Has pending notification
    spriteId: int        -- Sprite to render
}

-- Interactable ID for hover/click detection
export type InteractableID =
    | InteractConsole(BridgeStation)
    | InteractCrew(CrewID)
    | InteractHatch(int)  -- Deck number to transition to

-- =============================================================================
-- Observation Dome
-- =============================================================================

-- State for the observation dome (shows space exterior)
export type DomeViewState = {
    targetPlanetId: int,    -- Which planet is visible (0 = none)
    shipVelocity: float,    -- Current velocity for SR effects
    viewAngle: float        -- Camera angle in radians
}

-- =============================================================================
-- Bridge State
-- =============================================================================

-- Player movement state
export type MoveState =
    | MoveIdle
    | MoveWalking(Direction)
    | MoveTransitioning(int, Coord)  -- Transitioning to deck, target position

-- Complete bridge state
export type BridgeState = {
    -- Player
    playerPos: Coord,
    playerFacing: Direction,
    moveState: MoveState,

    -- Camera (follows player, used for viewport)
    cameraX: int,
    cameraY: int,

    -- Crew
    crewPositions: [CrewPosition],

    -- Consoles
    consoles: [ConsoleState],

    -- Interaction
    hoveredInteractable: Option[InteractableID],
    selectedInteractable: Option[InteractableID],

    -- Dome
    domeView: DomeViewState,

    -- Disc configuration (procedural - no stored layout)
    discRadius: int,        -- Radius of the walkable disc
    discCenterX: int,       -- Center X of disc
    discCenterY: int        -- Center Y of disc
}

-- =============================================================================
-- Bridge Input Result
-- =============================================================================

-- Result of processing bridge input
export type BridgeInputResult =
    | BridgeStay(BridgeState)              -- Stay on bridge with updated state
    | BridgeToGalaxyMap                     -- Transition to galaxy map
    | BridgeToDialogue(CrewID)              -- Start dialogue with crew
    | BridgeToDeck(int, Coord)              -- Transition to another deck

-- =============================================================================
-- Tile IDs (Bridge-specific sprites)
-- =============================================================================

-- Bridge tile sprite IDs (1000-1099 range)
export pure func tileFloor() -> int { 1000 }
export pure func tileFloorGlow() -> int { 1001 }
export pure func tileConsoleBase() -> int { 1002 }
export pure func tileWalkway() -> int { 1003 }
export pure func tileDomeEdge() -> int { 1004 }
export pure func tileWall() -> int { 1005 }
export pure func tileHatch() -> int { 1006 }
export pure func tileCaptainArea() -> int { 1007 }

-- Console sprite IDs (1100-1149 range)
export pure func spriteConsoleHelm() -> int { 1100 }
export pure func spriteConsoleComms() -> int { 1101 }
export pure func spriteConsoleStatus() -> int { 1102 }
export pure func spriteConsoleNav() -> int { 1103 }
export pure func spriteConsoleScience() -> int { 1104 }
export pure func spriteConsoleCaptain() -> int { 1105 }

-- Crew sprite IDs (1200-1249 range)
export pure func spriteCrewPilot() -> int { 1200 }
export pure func spriteCrewComms() -> int { 1201 }
export pure func spriteCrewEngineer() -> int { 1202 }
export pure func spriteCrewScientist() -> int { 1203 }
export pure func spriteCrewCaptain() -> int { 1204 }
export pure func spritePlayer() -> int { 1205 }

-- =============================================================================
-- Helper Functions
-- =============================================================================

-- Helper to construct Coord
pure func makeCoord(x: int, y: int) -> Coord {
    { x: x, y: y }
}

-- Distance squared from disc center (efficient - no sqrt needed)
pure func distSq(x: int, y: int, cx: int, cy: int) -> int {
    let dx = x - cx;
    let dy = y - cy;
    dx * dx + dy * dy
}

-- Check if a position is within the disc
export pure func isOnDisc(x: int, y: int, cx: int, cy: int, radius: int) -> bool {
    distSq(x, y, cx, cy) <= radius * radius
}

-- Check if a tile is walkable (procedural based on disc)
-- Uses squared distance to avoid expensive isqrt
export pure func isWalkable(state: BridgeState, x: int, y: int) -> bool {
    let dSq = distSq(x, y, state.discCenterX, state.discCenterY);
    let radiusSq = state.discRadius * state.discRadius;
    -- Walkable if within disc radius minus 1 (edge is not walkable)
    dSq < radiusSq
}

-- Get procedural tile type based on position on disc
-- Uses squared distances to avoid expensive isqrt (major perf win)
export pure func getTileType(x: int, y: int, cx: int, cy: int, radius: int) -> int {
    let dSq = distSq(x, y, cx, cy);
    let radiusSq = radius * radius;
    let edgeSq = (radius - 1) * (radius - 1);
    if dSq >= radiusSq then
        tileWall()          -- Outside disc = void
    else if dSq >= edgeSq then
        tileDomeEdge()      -- Edge of disc
    else if dSq <= 9 then
        tileCaptainArea()   -- Center = captain's area (d <= 3)
    else if dSq <= 36 then
        tileFloorGlow()     -- Inner ring = glowing floor (d <= 6)
    else if (x + y) % 8 == 0 then
        tileWalkway()       -- Radial walkways
    else
        tileFloor()         -- Normal floor
}

-- Viewport size (tiles visible in each direction from camera)
export pure func viewportSize() -> int { 10 }

-- Get sprite ID for a station
export pure func stationSprite(station: BridgeStation) -> int {
    match station {
        StationHelm => spriteConsoleHelm(),
        StationComms => spriteConsoleComms(),
        StationStatus => spriteConsoleStatus(),
        StationNav => spriteConsoleNav(),
        StationScience => spriteConsoleScience(),
        StationCaptain => spriteConsoleCaptain(),
        StationNone => 0
    }
}

-- Get sprite ID for a crew member based on their station
export pure func crewSprite(station: BridgeStation) -> int {
    match station {
        StationHelm => spriteCrewPilot(),
        StationComms => spriteCrewComms(),
        StationStatus => spriteCrewEngineer(),
        StationScience => spriteCrewScientist(),
        StationCaptain => spriteCrewCaptain(),
        StationNav => spriteCrewEngineer(),  -- Nav officer uses engineer sprite for now
        StationNone => spriteCrewPilot()     -- Default
    }
}

-- Move coordinate in direction
export pure func moveInDirection(pos: Coord, dir: Direction) -> Coord {
    let px = pos.x;
    let py = pos.y;
    match dir {
        North => makeCoord(px, py - 1),
        South => makeCoord(px, py + 1),
        East => makeCoord(px + 1, py),
        West => makeCoord(px - 1, py)
    }
}

-- =============================================================================
-- Console and Crew Definitions for Large Disc
-- =============================================================================

-- Disc configuration constants for 48x48 disc (radius 24, center 24,24)
export pure func discRadiusDefault() -> int { 24 }
export pure func discCenterDefault() -> int { 24 }

-- Create console state list - positioned around the large disc
-- Consoles are placed at various radii from center
export pure func createConsoles() -> [ConsoleState] {
    let cx = discCenterDefault();
    let cy = discCenterDefault();
    [
        -- Front consoles (toward "forward" of ship, y < center)
        { station: StationHelm, pos: makeCoord(cx, cy - 10), active: true, hasAlert: false, spriteId: spriteConsoleHelm() },
        { station: StationComms, pos: makeCoord(cx - 8, cy - 8), active: true, hasAlert: false, spriteId: spriteConsoleComms() },
        { station: StationStatus, pos: makeCoord(cx + 8, cy - 8), active: true, hasAlert: false, spriteId: spriteConsoleStatus() },
        -- Captain's chair at center
        { station: StationCaptain, pos: makeCoord(cx, cy), active: true, hasAlert: false, spriteId: spriteConsoleCaptain() },
        -- Side consoles (equatorial)
        { station: StationNav, pos: makeCoord(cx - 12, cy), active: true, hasAlert: false, spriteId: spriteConsoleNav() },
        { station: StationScience, pos: makeCoord(cx + 12, cy), active: true, hasAlert: false, spriteId: spriteConsoleScience() }
    ]
}

-- Create default crew positions - crew stand near their stations
export pure func createDefaultCrew() -> [CrewPosition] {
    let cx = discCenterDefault();
    let cy = discCenterDefault();
    [
        {
            crew: { id: 1, name: "Pilot Chen" },
            station: StationHelm,
            pos: makeCoord(cx, cy - 9),
            facing: North,
            activity: ActivityWorking
        },
        {
            crew: { id: 2, name: "Comms Officer Patel" },
            station: StationComms,
            pos: makeCoord(cx - 8, cy - 7),
            facing: North,
            activity: ActivityWorking
        },
        {
            crew: { id: 3, name: "Engineer Torres" },
            station: StationStatus,
            pos: makeCoord(cx + 8, cy - 7),
            facing: North,
            activity: ActivityWorking
        },
        {
            crew: { id: 4, name: "Navigator Kim" },
            station: StationNav,
            pos: makeCoord(cx - 11, cy),
            facing: East,
            activity: ActivityWorking
        },
        {
            crew: { id: 5, name: "Science Officer Okafor" },
            station: StationScience,
            pos: makeCoord(cx + 11, cy),
            facing: West,
            activity: ActivityWorking
        },
        {
            crew: { id: 6, name: "Captain Reyes" },
            station: StationCaptain,
            pos: makeCoord(cx, cy + 1),
            facing: North,
            activity: ActivityIdle
        }
    ]
}

-- =============================================================================
-- Bridge Initialization
-- =============================================================================

-- Create initial bridge state
export pure func initBridge() -> BridgeState {
    let cx = discCenterDefault();
    let cy = discCenterDefault();
    let radius = discRadiusDefault();
    {
        -- Player starts at south edge of disc (high y value)
        playerPos: makeCoord(cx, cy + 16),
        playerFacing: North,
        moveState: MoveIdle,

        -- Camera starts centered on player
        cameraX: cx,
        cameraY: cy + 16,

        -- Load crew
        crewPositions: createDefaultCrew(),

        -- Load consoles
        consoles: createConsoles(),

        -- No current interaction
        hoveredInteractable: None,
        selectedInteractable: None,

        -- Dome showing generic space view
        domeView: {
            targetPlanetId: 0,
            shipVelocity: 0.0,
            viewAngle: 0.0
        },

        -- Disc configuration
        discRadius: radius,
        discCenterX: cx,
        discCenterY: cy
    }
}

-- =============================================================================
-- Bridge Rendering Functions
-- =============================================================================

-- Layer constants for draw ordering
pure func layerFloor() -> int { 0 }
pure func layerConsoles() -> int { 1 }
pure func layerCrew() -> int { 2 }
pure func layerPlayer() -> int { 3 }

-- Default color (white, no tint) - 0xFFFFFFFF as decimal
pure func colorWhite() -> int { 4294967295 }

-- Screen center offset for centering the isometric grid
-- Screen is 1280x960, we want the grid centered horizontally
-- and positioned in the lower portion (below the dome)
pure func screenOffsetX() -> float { 640.0 }  -- Center horizontally
pure func screenOffsetY() -> float { 350.0 }  -- Lower portion, below dome

-- Render a single floor tile at world position, relative to camera
-- NOTE: Using Sprite instead of IsoTile due to AILANG type alias bug
pure func renderTileAt(worldX: int, worldY: int, camX: int, camY: int, sid: int) -> DrawCmd {
    -- Calculate position relative to camera (so camera is at screen center)
    let relX = worldX - camX;
    let relY = worldY - camY;
    -- Isometric projection: x' = (x - y) * tileWidth/2, y' = (x + y) * tileHeight/2
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    Sprite(sid, screenX, screenY, layerFloor())
}

-- Render tile row helper (recurses through x from start to maxX)
pure func renderFloorRowViewportRec(state: BridgeState, x: int, y: int, maxX: int, acc: [DrawCmd]) -> [DrawCmd] {
    if x > maxX then acc
    else renderFloorRowViewportRec(
        state,
        x + 1,
        y,
        maxX,
        renderTileAt(x, y, state.cameraX, state.cameraY,
            getTileType(x, y, state.discCenterX, state.discCenterY, state.discRadius)) :: acc
    )
}

-- Render one row of tiles in viewport
pure func renderFloorRowViewport(state: BridgeState, x: int, y: int, maxX: int) -> [DrawCmd] {
    renderFloorRowViewportRec(state, x, y, maxX, [])
}

-- Render all floor rows in viewport (procedural)
pure func renderFloorRowsViewport(state: BridgeState, y: int, maxY: int, minX: int, maxX: int) -> [DrawCmd] {
    if y > maxY then
        []
    else
        concat(
            renderFloorRowViewport(state, minX, y, maxX),
            renderFloorRowsViewport(state, y + 1, maxY, minX, maxX)
        )
}

-- Render all floor tiles within viewport around camera
export pure func renderBridgeFloor(state: BridgeState) -> [DrawCmd] {
    let vp = viewportSize();
    let minX = state.cameraX - vp;
    let maxX = state.cameraX + vp;
    let minY = state.cameraY - vp;
    let maxY = state.cameraY + vp;
    renderFloorRowsViewport(state, minY, maxY, minX, maxX)
}

-- Helper: check if world position is within viewport
pure func inViewport(wx: int, wy: int, camX: int, camY: int) -> bool {
    let vp = viewportSize();
    let dx = wx - camX;
    let dy = wy - camY;
    dx >= 0 - vp - 2 && dx <= vp + 2 && dy >= 0 - vp - 2 && dy <= vp + 2
}

-- Render a single console relative to camera
pure func renderConsole(console: ConsoleState, camX: int, camY: int) -> DrawCmd {
    let relX = console.pos.x - camX;
    let relY = console.pos.y - camY;
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    Sprite(console.spriteId, screenX, screenY, layerConsoles())
}

-- Render all consoles recursively (only those in viewport)
pure func renderConsolesRec(consoles: [ConsoleState], camX: int, camY: int) -> [DrawCmd] {
    match consoles {
        [] => [],
        c :: rest =>
            if inViewport(c.pos.x, c.pos.y, camX, camY) then
                renderConsole(c, camX, camY) :: renderConsolesRec(rest, camX, camY)
            else
                renderConsolesRec(rest, camX, camY)
    }
}

-- Render all console entities
export pure func renderConsoles(state: BridgeState) -> [DrawCmd] {
    renderConsolesRec(state.consoles, state.cameraX, state.cameraY)
}

-- Render a single crew member relative to camera
pure func renderCrewMember(crew: CrewPosition, camX: int, camY: int) -> DrawCmd {
    let relX = crew.pos.x - camX;
    let relY = crew.pos.y - camY;
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    Sprite(crewSprite(crew.station), screenX, screenY, layerCrew())
}

-- Render all crew recursively (only those in viewport)
pure func renderCrewRec(crew: [CrewPosition], camX: int, camY: int) -> [DrawCmd] {
    match crew {
        [] => [],
        c :: rest =>
            if inViewport(c.pos.x, c.pos.y, camX, camY) then
                renderCrewMember(c, camX, camY) :: renderCrewRec(rest, camX, camY)
            else
                renderCrewRec(rest, camX, camY)
    }
}

-- Render all crew members
export pure func renderBridgeCrew(state: BridgeState) -> [DrawCmd] {
    renderCrewRec(state.crewPositions, state.cameraX, state.cameraY)
}

-- Render the player entity (always at screen center since camera follows player)
export pure func renderPlayer(state: BridgeState) -> [DrawCmd] {
    let relX = state.playerPos.x - state.cameraX;
    let relY = state.playerPos.y - state.cameraY;
    let isoX = intToFloat((relX - relY) * 32);
    let isoY = intToFloat((relX + relY) * 16);
    let screenX = isoX + screenOffsetX();
    let screenY = isoY + screenOffsetY();
    [Sprite(spritePlayer(), screenX, screenY, layerPlayer())]
}

-- Render entire bridge (combines all layers)
export pure func renderBridge(state: BridgeState) -> [DrawCmd] {
    concat(
        concat(
            concat(renderBridgeFloor(state), renderConsoles(state)),
            renderBridgeCrew(state)
        ),
        renderPlayer(state)
    )
}

-- =============================================================================
-- Bridge Update Logic (Step function)
-- =============================================================================

-- Get direction to move based on frame and crew ID (deterministic patrol)
pure func getPatrolDirection(crewId: int, frame: int) -> Direction {
    -- Each crew member has a different patrol pattern based on ID
    let phase = (frame / 30 + crewId * 7) % 4;
    match phase {
        0 => North,
        1 => East,
        2 => South,
        _ => West
    }
}

-- Try to move a crew member, checking walkability
pure func tryMoveCrew(crew: CrewPosition, dir: Direction, state: BridgeState) -> CrewPosition {
    let newPos = moveInDirection(crew.pos, dir);
    if isWalkable(state, newPos.x, newPos.y) then
        { crew | pos: newPos, facing: dir }
    else
        { crew | facing: dir }  -- Just turn, don't move
}

-- Update a single crew member (patrol near their station)
pure func updateCrewMember(crew: CrewPosition, frame: int, state: BridgeState) -> CrewPosition {
    -- Only move every 30 frames (about 0.5 sec at 60fps)
    if frame % 30 == 0 then tryMoveCrew(crew, getPatrolDirection(crew.crew.id, frame), state) else crew
}

-- Update all crew recursively
pure func updateCrewRec(crew: [CrewPosition], frame: int, state: BridgeState) -> [CrewPosition] {
    match crew {
        [] => [],
        c :: rest => updateCrewMember(c, frame, state) :: updateCrewRec(rest, frame, state)
    }
}

-- Step the bridge state forward (called each frame)
export pure func stepBridge(state: BridgeState, frame: int) -> BridgeState {
    let updatedCrew = updateCrewRec(state.crewPositions, frame, state);
    { state | crewPositions: updatedCrew }
}
