// Code generated by ailang. DO NOT EDIT.
package sim_gen

import "fmt"

// RecordUpdate creates a new record with specified fields updated.
// AILANG: { base | field1: val1, field2: val2 }
func RecordUpdate(base interface{}, updates map[string]interface{}) interface{} {
	baseMap, ok := base.(map[string]interface{})
	if !ok {
		return updates
	}
	result := make(map[string]interface{}, len(baseMap)+len(updates))
	for k, v := range baseMap {
		result[k] = v
	}
	for k, v := range updates {
		result[k] = v
	}
	return result
}

// Cons prepends an element to a list (cons operator).
// AILANG: head :: tail
func Cons(head interface{}, tail interface{}) []interface{} {
	if tail == nil {
		return []interface{}{head}
	}
	list, ok := tail.([]interface{})
	if !ok {
		return []interface{}{head}
	}
	return append([]interface{}{head}, list...)
}

// AddInt adds two integers.
func AddInt(a, b interface{}) interface{} {
	return toInt64(a) + toInt64(b)
}

// SubInt subtracts two integers.
func SubInt(a, b interface{}) interface{} {
	return toInt64(a) - toInt64(b)
}

// MulInt multiplies two integers.
func MulInt(a, b interface{}) interface{} {
	return toInt64(a) * toInt64(b)
}

// DivInt divides two integers.
func DivInt(a, b interface{}) interface{} {
	return toInt64(a) / toInt64(b)
}

// ModInt returns integer modulo.
func ModInt(a, b interface{}) interface{} {
	return toInt64(a) % toInt64(b)
}

// AddFloat adds two floats.
func AddFloat(a, b interface{}) interface{} {
	return toFloat64(a) + toFloat64(b)
}

// SubFloat subtracts two floats.
func SubFloat(a, b interface{}) interface{} {
	return toFloat64(a) - toFloat64(b)
}

// MulFloat multiplies two floats.
func MulFloat(a, b interface{}) interface{} {
	return toFloat64(a) * toFloat64(b)
}

// DivFloat divides two floats.
func DivFloat(a, b interface{}) interface{} {
	return toFloat64(a) / toFloat64(b)
}

// IntToFloat converts int to float.
func IntToFloat(a interface{}) interface{} {
	return float64(toInt64(a))
}

// FloatToInt converts float to int.
func FloatToInt(a interface{}) interface{} {
	return int64(toFloat64(a))
}

// EqInt compares two integers for equality.
func EqInt(a, b interface{}) interface{} {
	return toInt64(a) == toInt64(b)
}

// LtInt compares two integers (less than).
func LtInt(a, b interface{}) interface{} {
	return toInt64(a) < toInt64(b)
}

// LeInt compares two integers (less or equal).
func LeInt(a, b interface{}) interface{} {
	return toInt64(a) <= toInt64(b)
}

// GtInt compares two integers (greater than).
func GtInt(a, b interface{}) interface{} {
	return toInt64(a) > toInt64(b)
}

// GeInt compares two integers (greater or equal).
func GeInt(a, b interface{}) interface{} {
	return toInt64(a) >= toInt64(b)
}

// NegInt negates an integer.
func NegInt(a interface{}) interface{} {
	return -toInt64(a)
}

// NegFloat negates a float.
func NegFloat(a interface{}) interface{} {
	return -toFloat64(a)
}

// toInt64 converts interface{} to int64.
func toInt64(v interface{}) int64 {
	switch x := v.(type) {
	case int64:
		return x
	case int:
		return int64(x)
	case float64:
		return int64(x)
	default:
		return 0
	}
}

// toFloat64 converts interface{} to float64.
func toFloat64(v interface{}) float64 {
	switch x := v.(type) {
	case float64:
		return x
	case int64:
		return float64(x)
	case int:
		return float64(x)
	default:
		return 0
	}
}

// CallFunc calls an interface{} as a function with the given arguments.
// Used for lambdas stored in variables.
func CallFunc(f interface{}, args ...interface{}) interface{} {
	switch fn := f.(type) {
	case func() interface{}:
		return fn()
	case func(interface{}) interface{}:
		if len(args) >= 1 {
			return fn(args[0])
		}
	case func(interface{}, interface{}) interface{}:
		if len(args) >= 2 {
			return fn(args[0], args[1])
		}
	case func(interface{}, interface{}, interface{}) interface{}:
		if len(args) >= 3 {
			return fn(args[0], args[1], args[2])
		}
	case func(...interface{}) interface{}:
		return fn(args...)
	}
	panic("CallFunc: unsupported function type")
}

// ListHead returns the first element of a list.
func ListHead(list interface{}) interface{} {
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[0]
	}
	return nil
}

// ListTail returns all but the first element of a list.
func ListTail(list interface{}) interface{} {
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[1:]
	}
	return []interface{}{}
}

// ListLen returns the length of a list.
func ListLen(list interface{}) int {
	if l, ok := list.([]interface{}); ok {
		return len(l)
	}
	return 0
}

// Show converts any value to its string representation.
func Show(v interface{}) string {
	switch x := v.(type) {
	case string:
		return x
	case int64:
		return fmt.Sprintf("%d", x)
	case int:
		return fmt.Sprintf("%d", x)
	case float64:
		return fmt.Sprintf("%g", x)
	case bool:
		if x { return "true" }
		return "false"
	case nil:
		return "()"
	default:
		return fmt.Sprintf("%v", x)
	}
}

// ConcatString concatenates two values as strings.
func ConcatString(a, b interface{}) string {
	return fmt.Sprintf("%v%v", a, b)
}

// Log prints a message and returns unit.
func Log(msg interface{}) interface{} {
	fmt.Println(msg)
	return struct{}{}
}

// Debug prints a debug message and returns unit.
func Debug(msg interface{}) interface{} {
	fmt.Printf("[DEBUG] %v\n", msg)
	return struct{}{}
}

// ConvertToInt64Slice converts []interface{} to []int64.
func ConvertToInt64Slice(v interface{}) []int64 {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]int64, len(slice))
	for i, elem := range slice {
		result[i] = toInt64(elem)
	}
	return result
}

// ConvertToStringSlice converts []interface{} to []string.
func ConvertToStringSlice(v interface{}) []string {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]string, len(slice))
	for i, elem := range slice {
		if s, ok := elem.(string); ok {
			result[i] = s
		}
	}
	return result
}

// ConvertToRecordSlice converts []interface{} to []map[string]interface{}.
func ConvertToRecordSlice(v interface{}) []map[string]interface{} {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]map[string]interface{}, len(slice))
	for i, elem := range slice {
		if m, ok := elem.(map[string]interface{}); ok {
			result[i] = m
		}
	}
	return result
}

func IsInBounds(x interface{}, y interface{}, width interface{}, height interface{}) interface{} {
	return 	func() interface{} {
		tmp1 := 		GeInt		(		x		, 		0		)		
		_ = tmp1 // suppress unused
		return 		func() interface{} {
			tmp2 := 			LtInt			(			x			, 			width			)			
			_ = tmp2 // suppress unused
			return 			func() interface{} {
				tmp3 := 				func() interface{} {
					if 					tmp1					.(bool) {
						return 						tmp2						
					}
					return 					false					
				}()				
				_ = tmp3 // suppress unused
				return 				func() interface{} {
					tmp4 := 					GeInt					(					y					, 					0					)					
					_ = tmp4 // suppress unused
					return 					func() interface{} {
						tmp5 := 						func() interface{} {
							if 							tmp3							.(bool) {
								return 								tmp4								
							}
							return 							false							
						}()						
						_ = tmp5 // suppress unused
						return 						func() interface{} {
							tmp6 := 							LtInt							(							y							, 							height							)							
							_ = tmp6 // suppress unused
							return 							func() interface{} {
								if 								tmp5								.(bool) {
									return 									tmp6									
								}
								return 								false								
							}()							
						}()						
					}()					
				}()				
			}()			
		}()		
	}()	
}

func directionDx(dir interface{}) interface{} {
	return 	func() interface{} {
		_scrutinee := 		dir		
		_ = _scrutinee // suppress unused
		_adt := _scrutinee.(*Direction)
		switch _adt.Kind {
		case DirectionKindNorth:
			return 			0			
		case DirectionKindSouth:
			return 			0			
		case DirectionKindEast:
			return 			1			
		case DirectionKindWest:
			return 			NegInt			(			1			)			
		default:
			panic("non-exhaustive match")
		}
	}()	
}

func directionDy(dir interface{}) interface{} {
	return 	func() interface{} {
		_scrutinee := 		dir		
		_ = _scrutinee // suppress unused
		_adt := _scrutinee.(*Direction)
		switch _adt.Kind {
		case DirectionKindNorth:
			return 			NegInt			(			1			)			
		case DirectionKindSouth:
			return 			1			
		case DirectionKindEast:
			return 			0			
		case DirectionKindWest:
			return 			0			
		default:
			panic("non-exhaustive match")
		}
	}()	
}

func indexToDirection(idx interface{}) interface{} {
	return 	func() interface{} {
		tmp7 := 		ModInt		(		idx		, 		4		)		
		_ = tmp7 // suppress unused
		return 		func() interface{} {
			_scrutinee := 			tmp7			
			_ = _scrutinee // suppress unused
			switch _scrutinee {
			case int64(0):
				return 				NewDirectionNorth()				
			case int64(1):
				return 				NewDirectionSouth()				
			case int64(2):
				return 				NewDirectionEast()				
			default:
				return 				NewDirectionWest()				
			}
		}()		
	}()	
}

func pathLength(path interface{}) interface{} {
	return 	func() interface{} {
		_scrutinee := 		path		
		_ = _scrutinee // suppress unused
		if ListLen(_scrutinee) == 0 {
			return 			0			
		} else if ListLen(_scrutinee) >= 1 {
			 := ListHead(_scrutinee)
			_ =  // suppress unused
			rest := ListTail(_scrutinee)
			_ = rest // suppress unused
			return 			func() interface{} {
				tmp8 := 				pathLength				(				rest				)				
				_ = tmp8 // suppress unused
				return 				AddInt				(				1				, 				tmp8				)				
			}()			
		} else {
			panic("non-exhaustive match")
		}
	}()	
}

func pathGet(path interface{}, idx interface{}) interface{} {
	return 	func() interface{} {
		_scrutinee := 		path		
		_ = _scrutinee // suppress unused
		if ListLen(_scrutinee) == 0 {
			return 			NewDirectionNorth()			
		} else if ListLen(_scrutinee) >= 1 {
			dir := ListHead(_scrutinee)
			_ = dir // suppress unused
			rest := ListTail(_scrutinee)
			_ = rest // suppress unused
			return 			func() interface{} {
				tmp9 := 				LeInt				(				idx				, 				0				)				
				_ = tmp9 // suppress unused
				return 				func() interface{} {
					if 					tmp9					.(bool) {
						return 						dir						
					}
					return 					func() interface{} {
						tmp10 := 						SubInt						(						idx						, 						1						)						
						_ = tmp10 // suppress unused
						return 						pathGet						(						rest						, 						tmp10						)						
					}()					
				}()				
			}()			
		} else {
			panic("non-exhaustive match")
		}
	}()	
}

func npcWithPos(npc interface{}, newX interface{}, newY interface{}) interface{} {
	return 	func() interface{} {
		tmp11 := 		map[string]interface{}{		"x": 		newX		, 		"y": 		newY		}		
		_ = tmp11 // suppress unused
		return 		RecordUpdate(		npc		, map[string]interface{}{		"pos": 		tmp11		})		
	}()	
}

func npcWithCounter(npc interface{}, counter interface{}) interface{} {
	return 	RecordUpdate(	npc	, map[string]interface{}{	"moveCounter": 	counter	})	
}

func TryMoveDirection(npc interface{}, dir interface{}, width interface{}, height interface{}) interface{} {
	return 	func() interface{} {
		dx := 		directionDx		(		dir		)		
		_ = dx // suppress unused
		return 		func() interface{} {
			dy := 			directionDy			(			dir			)			
			_ = dy // suppress unused
			return 			func() interface{} {
				newX := 				func() interface{} {
					tmp15 := 					npc					.(map[string]interface{})["pos"]					
					_ = tmp15 // suppress unused
					return 					func() interface{} {
						tmp16 := 						tmp15						.(map[string]interface{})["x"]						
						_ = tmp16 // suppress unused
						return 						AddInt						(						tmp16						, 						dx						)						
					}()					
				}()				
				_ = newX // suppress unused
				return 				func() interface{} {
					newY := 					func() interface{} {
						tmp13 := 						npc						.(map[string]interface{})["pos"]						
						_ = tmp13 // suppress unused
						return 						func() interface{} {
							tmp14 := 							tmp13							.(map[string]interface{})["y"]							
							_ = tmp14 // suppress unused
							return 							AddInt							(							tmp14							, 							dy							)							
						}()						
					}()					
					_ = newY // suppress unused
					return 					func() interface{} {
						tmp12 := 						IsInBounds						(						newX						, 						newY						, 						width						, 						height						)						
						_ = tmp12 // suppress unused
						return 						func() interface{} {
							if 							tmp12							.(bool) {
								return 								npcWithPos								(								npc								, 								newX								, 								newY								)								
							}
							return 							npc							
						}()						
					}()					
				}()				
			}()			
		}()		
	}()	
}

func updateRandomWalk(npc interface{}, interval interface{}, width interface{}, height interface{}) interface{} {
	return 	func() interface{} {
		tmp17 := 		npc		.(map[string]interface{})["moveCounter"]		
		_ = tmp17 // suppress unused
		return 		func() interface{} {
			tmp18 := 			LeInt			(			tmp17			, 			0			)			
			_ = tmp18 // suppress unused
			return 			func() interface{} {
				if 				tmp18				.(bool) {
					return 					func() interface{} {
						dirIndex := 						RandInt						(						0						, 						3						)						
						_ = dirIndex // suppress unused
						return 						func() interface{} {
							dir := 							indexToDirection							(							dirIndex							)							
							_ = dir // suppress unused
							return 							func() interface{} {
								movedNpc := 								TryMoveDirection								(								npc								, 								dir								, 								width								, 								height								)								
								_ = movedNpc // suppress unused
								return 								npcWithCounter								(								movedNpc								, 								interval								)								
							}()							
						}()						
					}()					
				}
				return 				func() interface{} {
					tmp19 := 					npc					.(map[string]interface{})["moveCounter"]					
					_ = tmp19 // suppress unused
					return 					func() interface{} {
						tmp20 := 						SubInt						(						tmp19						, 						1						)						
						_ = tmp20 // suppress unused
						return 						npcWithCounter						(						npc						, 						tmp20						)						
					}()					
				}()				
			}()			
		}()		
	}()	
}

func updatePatrol(npc interface{}, path interface{}, width interface{}, height interface{}) interface{} {
	return 	func() interface{} {
		len := 		pathLength		(		path		)		
		_ = len // suppress unused
		return 		func() interface{} {
			tmp21 := 			LeInt			(			len			, 			0			)			
			_ = tmp21 // suppress unused
			return 			func() interface{} {
				if 				tmp21				.(bool) {
					return 					npc					
				}
				return 				func() interface{} {
					tmp22 := 					npc					.(map[string]interface{})["moveCounter"]					
					_ = tmp22 // suppress unused
					return 					func() interface{} {
						tmp23 := 						LeInt						(						tmp22						, 						0						)						
						_ = tmp23 // suppress unused
						return 						func() interface{} {
							if 							tmp23							.(bool) {
								return 								func() interface{} {
									dir := 									func() interface{} {
										tmp26 := 										npc										.(map[string]interface{})["patrolIndex"]										
										_ = tmp26 // suppress unused
										return 										pathGet										(										path										, 										tmp26										)										
									}()									
									_ = dir // suppress unused
									return 									func() interface{} {
										movedNpc := 										TryMoveDirection										(										npc										, 										dir										, 										width										, 										height										)										
										_ = movedNpc // suppress unused
										return 										func() interface{} {
											nextIndex := 											func() interface{} {
												tmp24 := 												npc												.(map[string]interface{})["patrolIndex"]												
												_ = tmp24 // suppress unused
												return 												func() interface{} {
													tmp25 := 													AddInt													(													tmp24													, 													1													)													
													_ = tmp25 // suppress unused
													return 													ModInt													(													tmp25													, 													len													)													
												}()												
											}()											
											_ = nextIndex // suppress unused
											return 											RecordUpdate(											movedNpc											, map[string]interface{}{											"patrolIndex": 											nextIndex											, 											"moveCounter": 											20											})											
										}()										
									}()									
								}()								
							}
							return 							func() interface{} {
								tmp27 := 								npc								.(map[string]interface{})["moveCounter"]								
								_ = tmp27 // suppress unused
								return 								func() interface{} {
									tmp28 := 									SubInt									(									tmp27									, 									1									)									
									_ = tmp28 // suppress unused
									return 									npcWithCounter									(									npc									, 									tmp28									)									
								}()								
							}()							
						}()						
					}()					
				}()				
			}()			
		}()		
	}()	
}

func UpdateNPC(npc interface{}, width interface{}, height interface{}) interface{} {
	return 	func() interface{} {
		tmp29 := 		npc		.(map[string]interface{})["pattern"]		
		_ = tmp29 // suppress unused
		return 		func() interface{} {
			_scrutinee := 			tmp29			
			_ = _scrutinee // suppress unused
			_adt := _scrutinee.(*MovementPattern)
			switch _adt.Kind {
			case MovementPatternKindPatternStatic:
				return 				npc				
			case MovementPatternKindPatternRandomWalk:
				interval := _adt.PatternRandomWalk.Value0
				_ = interval // suppress unused
				return 				updateRandomWalk				(				npc				, 				interval				, 				width				, 				height				)				
			case MovementPatternKindPatternPatrol:
				path := _adt.PatternPatrol.Value0
				_ = path // suppress unused
				return 				updatePatrol				(				npc				, 				path				, 				width				, 				height				)				
			default:
				panic("non-exhaustive match")
			}
		}()		
	}()	
}

func UpdateAllNPCs(npcs interface{}, width interface{}, height interface{}) interface{} {
	return 	func() interface{} {
		_scrutinee := 		npcs		
		_ = _scrutinee // suppress unused
		if ListLen(_scrutinee) == 0 {
			return 			[]interface{}{			}			
		} else if ListLen(_scrutinee) >= 1 {
			npc := ListHead(_scrutinee)
			_ = npc // suppress unused
			rest := ListTail(_scrutinee)
			_ = rest // suppress unused
			return 			func() interface{} {
				tmp30 := 				UpdateNPC				(				npc				, 				width				, 				height				)				
				_ = tmp30 // suppress unused
				return 				func() interface{} {
					tmp31 := 					UpdateAllNPCs					(					rest					, 					width					, 					height					)					
					_ = tmp31 // suppress unused
					return 					Cons(					tmp30					, 					tmp31					)					
				}()				
			}()			
		} else {
			panic("non-exhaustive match")
		}
	}()	
}

