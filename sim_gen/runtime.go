// Code generated by ailang. DO NOT EDIT.
// Runtime helpers for AILANG generated code.
package sim_gen

import "fmt"

// RecordUpdate creates a new record with specified fields updated.
// AILANG: { base | field1: val1, field2: val2 }
func RecordUpdate(base interface{}, updates map[string]interface{}) interface{} {
	baseMap, ok := base.(map[string]interface{})
	if !ok {
		return updates
	}
	result := make(map[string]interface{}, len(baseMap)+len(updates))
	for k, v := range baseMap {
		result[k] = v
	}
	for k, v := range updates {
		result[k] = v
	}
	return result
}

// Cons prepends an element to a list (cons operator).
// AILANG: head :: tail
func Cons(head interface{}, tail interface{}) []interface{} {
	if tail == nil {
		return []interface{}{head}
	}
	list, ok := tail.([]interface{})
	if !ok {
		return []interface{}{head}
	}
	return append([]interface{}{head}, list...)
}

// AddInt adds two integers.
func AddInt(a, b interface{}) interface{} {
	return toInt64(a) + toInt64(b)
}

// SubInt subtracts two integers.
func SubInt(a, b interface{}) interface{} {
	return toInt64(a) - toInt64(b)
}

// MulInt multiplies two integers.
func MulInt(a, b interface{}) interface{} {
	return toInt64(a) * toInt64(b)
}

// DivInt divides two integers.
func DivInt(a, b interface{}) interface{} {
	return toInt64(a) / toInt64(b)
}

// ModInt returns integer modulo.
func ModInt(a, b interface{}) interface{} {
	return toInt64(a) % toInt64(b)
}

// AddFloat adds two floats.
func AddFloat(a, b interface{}) interface{} {
	return toFloat64(a) + toFloat64(b)
}

// SubFloat subtracts two floats.
func SubFloat(a, b interface{}) interface{} {
	return toFloat64(a) - toFloat64(b)
}

// MulFloat multiplies two floats.
func MulFloat(a, b interface{}) interface{} {
	return toFloat64(a) * toFloat64(b)
}

// DivFloat divides two floats.
func DivFloat(a, b interface{}) interface{} {
	return toFloat64(a) / toFloat64(b)
}

// IntToFloat converts int to float.
func IntToFloat(a interface{}) interface{} {
	return float64(toInt64(a))
}

// FloatToInt converts float to int.
func FloatToInt(a interface{}) interface{} {
	return int64(toFloat64(a))
}

// EqInt compares two integers for equality.
func EqInt(a, b interface{}) interface{} {
	return toInt64(a) == toInt64(b)
}

// LtInt compares two integers (less than).
func LtInt(a, b interface{}) interface{} {
	return toInt64(a) < toInt64(b)
}

// LeInt compares two integers (less or equal).
func LeInt(a, b interface{}) interface{} {
	return toInt64(a) <= toInt64(b)
}

// GtInt compares two integers (greater than).
func GtInt(a, b interface{}) interface{} {
	return toInt64(a) > toInt64(b)
}

// GeInt compares two integers (greater or equal).
func GeInt(a, b interface{}) interface{} {
	return toInt64(a) >= toInt64(b)
}

// NegInt negates an integer.
func NegInt(a interface{}) interface{} {
	return -toInt64(a)
}

// NegFloat negates a float.
func NegFloat(a interface{}) interface{} {
	return -toFloat64(a)
}

// toInt64 converts interface{} to int64.
func toInt64(v interface{}) int64 {
	switch x := v.(type) {
	case int64:
		return x
	case int:
		return int64(x)
	case float64:
		return int64(x)
	default:
		return 0
	}
}

// toFloat64 converts interface{} to float64.
func toFloat64(v interface{}) float64 {
	switch x := v.(type) {
	case float64:
		return x
	case int64:
		return float64(x)
	case int:
		return float64(x)
	default:
		return 0
	}
}

// CallFunc calls an interface{} as a function with the given arguments.
// Used for lambdas stored in variables.
func CallFunc(f interface{}, args ...interface{}) interface{} {
	switch fn := f.(type) {
	case func() interface{}:
		return fn()
	case func(interface{}) interface{}:
		if len(args) >= 1 {
			return fn(args[0])
		}
	case func(interface{}, interface{}) interface{}:
		if len(args) >= 2 {
			return fn(args[0], args[1])
		}
	case func(interface{}, interface{}, interface{}) interface{}:
		if len(args) >= 3 {
			return fn(args[0], args[1], args[2])
		}
	case func(...interface{}) interface{}:
		return fn(args...)
	}
	panic("CallFunc: unsupported function type")
}

// ListHead returns the first element of a list.
func ListHead(list interface{}) interface{} {
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[0]
	}
	return nil
}

// ListTail returns all but the first element of a list.
func ListTail(list interface{}) interface{} {
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[1:]
	}
	return []interface{}{}
}

// ListLen returns the length of a list.
func ListLen(list interface{}) int {
	if l, ok := list.([]interface{}); ok {
		return len(l)
	}
	return 0
}

// Show converts any value to its string representation.
func Show(v interface{}) string {
	switch x := v.(type) {
	case string:
		return x
	case int64:
		return fmt.Sprintf("%d", x)
	case int:
		return fmt.Sprintf("%d", x)
	case float64:
		return fmt.Sprintf("%g", x)
	case bool:
		if x {
			return "true"
		}
		return "false"
	case nil:
		return "()"
	default:
		return fmt.Sprintf("%v", x)
	}
}

// ConcatString concatenates two values as strings.
func ConcatString(a, b interface{}) string {
	return fmt.Sprintf("%v%v", a, b)
}

// Log prints a message and returns unit.
func Log(msg interface{}) interface{} {
	fmt.Println(msg)
	return struct{}{}
}

// Debug prints a debug message and returns unit.
func Debug(msg interface{}) interface{} {
	fmt.Printf("[DEBUG] %v\n", msg)
	return struct{}{}
}

// ConvertToInt64Slice converts []interface{} to []int64.
func ConvertToInt64Slice(v interface{}) []int64 {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]int64, len(slice))
	for i, elem := range slice {
		result[i] = toInt64(elem)
	}
	return result
}

// ConvertToStringSlice converts []interface{} to []string.
func ConvertToStringSlice(v interface{}) []string {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]string, len(slice))
	for i, elem := range slice {
		if s, ok := elem.(string); ok {
			result[i] = s
		}
	}
	return result
}

// ConvertToRecordSlice converts []interface{} to []map[string]interface{}.
func ConvertToRecordSlice(v interface{}) []map[string]interface{} {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]map[string]interface{}, len(slice))
	for i, elem := range slice {
		if m, ok := elem.(map[string]interface{}); ok {
			result[i] = m
		}
	}
	return result
}
