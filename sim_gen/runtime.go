// Code generated by ailang. DO NOT EDIT.
// Runtime helpers for AILANG generated code.
package sim_gen

import (
	"fmt"
	"reflect"
	"strings"
)

// RecordUpdate creates a new record with specified fields updated.
// AILANG: { base | field1: val1, field2: val2 }
// M-DX16: Preserves typed structs using reflection.
func RecordUpdate(base interface{}, updates map[string]interface{}) interface{} {
	// Handle map[string]interface{} (original behavior)
	if baseMap, ok := base.(map[string]interface{}); ok {
		result := make(map[string]interface{}, len(baseMap)+len(updates))
		for k, v := range baseMap {
			result[k] = v
		}
		for k, v := range updates {
			result[k] = v
		}
		return result
	}

	// Handle typed structs using reflection
	baseVal := reflect.ValueOf(base)
	if baseVal.Kind() == reflect.Ptr && baseVal.Elem().Kind() == reflect.Struct {
		// Create a new instance and copy all fields
		newPtr := reflect.New(baseVal.Elem().Type())
		newVal := newPtr.Elem()
		oldVal := baseVal.Elem()

		// Copy all fields from base
		for i := 0; i < oldVal.NumField(); i++ {
			if newVal.Field(i).CanSet() {
				newVal.Field(i).Set(oldVal.Field(i))
			}
		}

		// Apply updates (field names are lowercase in AILANG, PascalCase in Go)
		for fieldName, val := range updates {
			// Convert field name to PascalCase
			goFieldName := strings.ToUpper(fieldName[:1]) + fieldName[1:]
			field := newVal.FieldByName(goFieldName)
			if field.IsValid() && field.CanSet() {
				// Handle type conversion
				valReflect := reflect.ValueOf(val)
				if valReflect.Type().AssignableTo(field.Type()) {
					field.Set(valReflect)
				} else if valReflect.Kind() == reflect.Ptr && field.Kind() != reflect.Ptr {
					// M-DX20: Dereference pointer if field expects value type
					if valReflect.Elem().Type().AssignableTo(field.Type()) {
						field.Set(valReflect.Elem())
					}
				} else if valReflect.Kind() == reflect.Slice && field.Kind() == reflect.Slice {
					// M-DX19: Convert []interface{} to typed slice via reflection
					elemType := field.Type().Elem()
					newSlice := reflect.MakeSlice(field.Type(), valReflect.Len(), valReflect.Len())
					for i := 0; i < valReflect.Len(); i++ {
						elem := valReflect.Index(i)
						// Handle interface{} elements
						if elem.Kind() == reflect.Interface {
							elem = elem.Elem()
						}
						if elem.Type().AssignableTo(elemType) {
							newSlice.Index(i).Set(elem)
						} else if elem.Type().ConvertibleTo(elemType) {
							newSlice.Index(i).Set(elem.Convert(elemType))
						}
					}
					field.Set(newSlice)
				} else if valReflect.Type().ConvertibleTo(field.Type()) {
					field.Set(valReflect.Convert(field.Type()))
				} else {
					// Try to set directly for interface{} values
					field.Set(valReflect)
				}
			}
		}
		return newPtr.Interface()
	}

	// Fallback: create map from updates
	return updates
}

// FieldGet retrieves a field from a record (map or typed struct).
// M-DX18: Handles both map[string]interface{} and typed structs.
func FieldGet(record interface{}, field string) interface{} {
	// Handle map[string]interface{}
	if m, ok := record.(map[string]interface{}); ok {
		return m[field]
	}

	// Handle typed struct using reflection
	val := reflect.ValueOf(record)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	if val.Kind() == reflect.Struct {
		// Convert field name to PascalCase (AILANG lowercase -> Go PascalCase)
		goField := strings.ToUpper(field[:1]) + field[1:]
		f := val.FieldByName(goField)
		if f.IsValid() {
			// M-DX21: Return pointer for struct-typed fields (AILANG expects *Struct)
			if f.Kind() == reflect.Struct && f.CanAddr() {
				return f.Addr().Interface()
			}
			return f.Interface()
		}
	}
	return nil
}

// Cons prepends an element to a list (cons operator).
// AILANG: head :: tail
func Cons(head interface{}, tail interface{}) []interface{} {
	if tail == nil {
		return []interface{}{head}
	}
	list, ok := tail.([]interface{})
	if !ok {
		return []interface{}{head}
	}
	return append([]interface{}{head}, list...)
}

// AddInt adds two integers.
func AddInt(a, b interface{}) interface{} {
	return toInt64(a) + toInt64(b)
}

// SubInt subtracts two integers.
func SubInt(a, b interface{}) interface{} {
	return toInt64(a) - toInt64(b)
}

// MulInt multiplies two integers.
func MulInt(a, b interface{}) interface{} {
	return toInt64(a) * toInt64(b)
}

// DivInt divides two integers.
func DivInt(a, b interface{}) interface{} {
	return toInt64(a) / toInt64(b)
}

// ModInt returns integer modulo.
func ModInt(a, b interface{}) interface{} {
	return toInt64(a) % toInt64(b)
}

// AddFloat adds two floats.
func AddFloat(a, b interface{}) interface{} {
	return toFloat64(a) + toFloat64(b)
}

// SubFloat subtracts two floats.
func SubFloat(a, b interface{}) interface{} {
	return toFloat64(a) - toFloat64(b)
}

// MulFloat multiplies two floats.
func MulFloat(a, b interface{}) interface{} {
	return toFloat64(a) * toFloat64(b)
}

// DivFloat divides two floats.
func DivFloat(a, b interface{}) interface{} {
	return toFloat64(a) / toFloat64(b)
}

// IntToFloat converts int to float.
func IntToFloat(a interface{}) interface{} {
	return float64(toInt64(a))
}

// FloatToInt converts float to int.
func FloatToInt(a interface{}) interface{} {
	return int64(toFloat64(a))
}

// EqInt compares two integers for equality.
func EqInt(a, b interface{}) interface{} {
	return toInt64(a) == toInt64(b)
}

// LtInt compares two integers (less than).
func LtInt(a, b interface{}) interface{} {
	return toInt64(a) < toInt64(b)
}

// LeInt compares two integers (less or equal).
func LeInt(a, b interface{}) interface{} {
	return toInt64(a) <= toInt64(b)
}

// GtInt compares two integers (greater than).
func GtInt(a, b interface{}) interface{} {
	return toInt64(a) > toInt64(b)
}

// GeInt compares two integers (greater or equal).
func GeInt(a, b interface{}) interface{} {
	return toInt64(a) >= toInt64(b)
}

// NegInt negates an integer.
func NegInt(a interface{}) interface{} {
	return -toInt64(a)
}

// NegFloat negates a float.
func NegFloat(a interface{}) interface{} {
	return -toFloat64(a)
}

// toInt64 converts interface{} to int64.
func toInt64(v interface{}) int64 {
	switch x := v.(type) {
	case int64:
		return x
	case int:
		return int64(x)
	case float64:
		return int64(x)
	default:
		return 0
	}
}

// toFloat64 converts interface{} to float64.
func toFloat64(v interface{}) float64 {
	switch x := v.(type) {
	case float64:
		return x
	case int64:
		return float64(x)
	case int:
		return float64(x)
	default:
		return 0
	}
}

// CallFunc calls an interface{} as a function with the given arguments.
// Used for lambdas stored in variables.
func CallFunc(f interface{}, args ...interface{}) interface{} {
	switch fn := f.(type) {
	case func() interface{}:
		return fn()
	case func(interface{}) interface{}:
		if len(args) >= 1 {
			return fn(args[0])
		}
	case func(interface{}, interface{}) interface{}:
		if len(args) >= 2 {
			return fn(args[0], args[1])
		}
	case func(interface{}, interface{}, interface{}) interface{}:
		if len(args) >= 3 {
			return fn(args[0], args[1], args[2])
		}
	case func(...interface{}) interface{}:
		return fn(args...)
	}
	panic("CallFunc: unsupported function type")
}

// ListHead returns the first element of a list.
func ListHead(list interface{}) interface{} {
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[0]
	}
	return nil
}

// ListTail returns all but the first element of a list.
func ListTail(list interface{}) interface{} {
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[1:]
	}
	return []interface{}{}
}

// ListLen returns the length of a list.
func ListLen(list interface{}) int {
	if l, ok := list.([]interface{}); ok {
		return len(l)
	}
	return 0
}

// Show converts any value to its string representation.
func Show(v interface{}) string {
	switch x := v.(type) {
	case string:
		return x
	case int64:
		return fmt.Sprintf("%d", x)
	case int:
		return fmt.Sprintf("%d", x)
	case float64:
		return fmt.Sprintf("%g", x)
	case bool:
		if x {
			return "true"
		}
		return "false"
	case nil:
		return "()"
	default:
		return fmt.Sprintf("%v", x)
	}
}

// ConcatString concatenates two values as strings.
func ConcatString(a, b interface{}) string {
	return fmt.Sprintf("%v%v", a, b)
}

// Log prints a message and returns unit.
func Log(msg interface{}) interface{} {
	fmt.Println(msg)
	return struct{}{}
}

// Debug prints a debug message and returns unit.
func Debug(msg interface{}) interface{} {
	fmt.Printf("[DEBUG] %v\n", msg)
	return struct{}{}
}

// ConvertToInt64Slice converts []interface{} to []int64.
func ConvertToInt64Slice(v interface{}) []int64 {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]int64, len(slice))
	for i, elem := range slice {
		result[i] = toInt64(elem)
	}
	return result
}

// ConvertToStringSlice converts []interface{} to []string.
func ConvertToStringSlice(v interface{}) []string {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]string, len(slice))
	for i, elem := range slice {
		if s, ok := elem.(string); ok {
			result[i] = s
		}
	}
	return result
}

// ConvertToRecordSlice converts []interface{} to []map[string]interface{}.
func ConvertToRecordSlice(v interface{}) []map[string]interface{} {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]map[string]interface{}, len(slice))
	for i, elem := range slice {
		if m, ok := elem.(map[string]interface{}); ok {
			result[i] = m
		}
	}
	return result
}

// FromList creates an array from a list.
// In Go, both arrays and lists are []interface{}.
func FromList(xs interface{}) interface{} {
	if xs == nil {
		return []interface{}{}
	}
	if list, ok := xs.([]interface{}); ok {
		// Return a copy to preserve immutability
		result := make([]interface{}, len(list))
		copy(result, list)
		return result
	}
	return []interface{}{}
}

// ToList converts an array to a list.
// In Go, both are []interface{}, so this is essentially identity.
func ToList(arr interface{}) interface{} {
	if arr == nil {
		return []interface{}{}
	}
	if slice, ok := arr.([]interface{}); ok {
		result := make([]interface{}, len(slice))
		copy(result, slice)
		return result
	}
	return []interface{}{}
}

// Length returns the length of an array.
func Length(arr interface{}) interface{} {
	if arr == nil {
		return int64(0)
	}
	if slice, ok := arr.([]interface{}); ok {
		return int64(len(slice))
	}
	return int64(0)
}

// Get returns the element at the given index.
// Panics if index is out of bounds.
func Get(arr interface{}, idx interface{}) interface{} {
	i := toInt64(idx)
	if slice, ok := arr.([]interface{}); ok {
		if i < 0 || i >= int64(len(slice)) {
			panic(fmt.Sprintf("array index out of bounds: %d (length %d)", i, len(slice)))
		}
		return slice[i]
	}
	panic("Get: not an array")
}

// GetOpt safely returns the element at index, or None if out of bounds.
// Returns Some(element) or None. Uses makeOptionSome/makeOptionNone helpers
// which delegate to typed constructors if Option ADT is present.
func GetOpt(arr interface{}, idx interface{}) interface{} {
	i := toInt64(idx)
	if i < 0 {
		return makeOptionNone()
	}
	if slice, ok := arr.([]interface{}); ok {
		if i >= int64(len(slice)) {
			return makeOptionNone()
		}
		return makeOptionSome(slice[i])
	}
	return makeOptionNone()
}

// makeOptionSome creates a Some value.
// Uses map representation for runtime compatibility.
func makeOptionSome(v interface{}) interface{} {
	return map[string]interface{}{"tag": "Some", "value": v}
}

// makeOptionNone creates a None value.
// Uses map representation for runtime compatibility.
func makeOptionNone() interface{} {
	return map[string]interface{}{"tag": "None"}
}

// UnsafeGet returns element at index without bounds checking.
// Caller must ensure index is valid.
func UnsafeGet(arr interface{}, idx interface{}) interface{} {
	i := toInt64(idx)
	if slice, ok := arr.([]interface{}); ok {
		return slice[i]
	}
	panic("UnsafeGet: not an array")
}

// Set returns a new array with the element at index updated.
// Preserves immutability by creating a copy.
func Set(arr interface{}, idx interface{}, val interface{}) interface{} {
	i := toInt64(idx)
	if slice, ok := arr.([]interface{}); ok {
		if i < 0 || i >= int64(len(slice)) {
			panic(fmt.Sprintf("array index out of bounds: %d (length %d)", i, len(slice)))
		}
		result := make([]interface{}, len(slice))
		copy(result, slice)
		result[i] = val
		return result
	}
	panic("Set: not an array")
}

// Make creates an array of given size with all elements set to default.
func Make(size interface{}, defaultVal interface{}) interface{} {
	n := toInt64(size)
	if n < 0 {
		n = 0
	}
	result := make([]interface{}, n)
	for i := range result {
		result[i] = defaultVal
	}
	return result
}

// convertToClickKindSlice converts []interface{} to []*ClickKind.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToClickKindSlice(v interface{}) []*ClickKind {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToClickKindSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ClickKind{}
	}
	out := make([]*ClickKind, len(src))
	for i, e := range src {
		elem, ok := e.(*ClickKind)
		if !ok {
			panic(fmt.Sprintf("convertToClickKindSlice: element %d: expected *ClickKind, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToDirectionSlice converts []interface{} to []*Direction.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToDirectionSlice(v interface{}) []*Direction {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToDirectionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Direction{}
	}
	out := make([]*Direction, len(src))
	for i, e := range src {
		elem, ok := e.(*Direction)
		if !ok {
			panic(fmt.Sprintf("convertToDirectionSlice: element %d: expected *Direction, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToDrawCmdSlice converts []interface{} to []*DrawCmd.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToDrawCmdSlice(v interface{}) []*DrawCmd {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToDrawCmdSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*DrawCmd{}
	}
	out := make([]*DrawCmd, len(src))
	for i, e := range src {
		elem, ok := e.(*DrawCmd)
		if !ok {
			panic(fmt.Sprintf("convertToDrawCmdSlice: element %d: expected *DrawCmd, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToKeyEventSlice converts []interface{} to []*KeyEvent.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToKeyEventSlice(v interface{}) []*KeyEvent {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToKeyEventSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*KeyEvent{}
	}
	out := make([]*KeyEvent, len(src))
	for i, e := range src {
		elem, ok := e.(*KeyEvent)
		if !ok {
			panic(fmt.Sprintf("convertToKeyEventSlice: element %d: expected *KeyEvent, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToMovementPatternSlice converts []interface{} to []*MovementPattern.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToMovementPatternSlice(v interface{}) []*MovementPattern {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToMovementPatternSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*MovementPattern{}
	}
	out := make([]*MovementPattern, len(src))
	for i, e := range src {
		elem, ok := e.(*MovementPattern)
		if !ok {
			panic(fmt.Sprintf("convertToMovementPatternSlice: element %d: expected *MovementPattern, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToNPCSlice converts []interface{} to []*NPC.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToNPCSlice(v interface{}) []*NPC {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToNPCSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*NPC{}
	}
	out := make([]*NPC, len(src))
	for i, e := range src {
		elem, ok := e.(*NPC)
		if !ok {
			panic(fmt.Sprintf("convertToNPCSlice: element %d: expected *NPC, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToOptionSlice converts []interface{} to []*Option.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToOptionSlice(v interface{}) []*Option {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToOptionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Option{}
	}
	out := make([]*Option, len(src))
	for i, e := range src {
		elem, ok := e.(*Option)
		if !ok {
			panic(fmt.Sprintf("convertToOptionSlice: element %d: expected *Option, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToPlayerActionSlice converts []interface{} to []*PlayerAction.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToPlayerActionSlice(v interface{}) []*PlayerAction {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToPlayerActionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*PlayerAction{}
	}
	out := make([]*PlayerAction, len(src))
	for i, e := range src {
		elem, ok := e.(*PlayerAction)
		if !ok {
			panic(fmt.Sprintf("convertToPlayerActionSlice: element %d: expected *PlayerAction, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToSelectionSlice converts []interface{} to []*Selection.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToSelectionSlice(v interface{}) []*Selection {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToSelectionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Selection{}
	}
	out := make([]*Selection, len(src))
	for i, e := range src {
		elem, ok := e.(*Selection)
		if !ok {
			panic(fmt.Sprintf("convertToSelectionSlice: element %d: expected *Selection, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToStructureTypeSlice converts []interface{} to []*StructureType.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToStructureTypeSlice(v interface{}) []*StructureType {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToStructureTypeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*StructureType{}
	}
	out := make([]*StructureType, len(src))
	for i, e := range src {
		elem, ok := e.(*StructureType)
		if !ok {
			panic(fmt.Sprintf("convertToStructureTypeSlice: element %d: expected *StructureType, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToTileSlice converts []interface{} to []*Tile.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToTileSlice(v interface{}) []*Tile {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToTileSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Tile{}
	}
	out := make([]*Tile, len(src))
	for i, e := range src {
		elem, ok := e.(*Tile)
		if !ok {
			panic(fmt.Sprintf("convertToTileSlice: element %d: expected *Tile, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// convertToUiKindSlice converts []interface{} to []*UiKind.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func convertToUiKindSlice(v interface{}) []*UiKind {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("convertToUiKindSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*UiKind{}
	}
	out := make([]*UiKind, len(src))
	for i, e := range src {
		elem, ok := e.(*UiKind)
		if !ok {
			panic(fmt.Sprintf("convertToUiKindSlice: element %d: expected *UiKind, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}
