// Code generated by ailang. DO NOT EDIT.
// Runtime helpers for AILANG generated code.
package sim_gen

import (
	"fmt"
	"reflect"
	"strings"
)

// RecordUpdate creates a new record with specified fields updated.
// AILANG: { base | field1: val1, field2: val2 }
// M-DX16: Preserves typed structs using reflection.
func RecordUpdate(base interface{}, updates map[string]interface{}) interface{} {
	// Handle map[string]interface{} (original behavior)
	if baseMap, ok := base.(map[string]interface{}); ok {
		result := make(map[string]interface{}, len(baseMap)+len(updates))
		for k, v := range baseMap {
			result[k] = v
		}
		for k, v := range updates {
			result[k] = v
		}
		return result
	}

	// Handle typed structs using reflection
	baseVal := reflect.ValueOf(base)
	if baseVal.Kind() == reflect.Ptr && baseVal.Elem().Kind() == reflect.Struct {
		// Create a new instance and copy all fields
		newPtr := reflect.New(baseVal.Elem().Type())
		newVal := newPtr.Elem()
		oldVal := baseVal.Elem()

		// Copy all fields from base
		for i := 0; i < oldVal.NumField(); i++ {
			if newVal.Field(i).CanSet() {
				newVal.Field(i).Set(oldVal.Field(i))
			}
		}

		// Apply updates (field names are lowercase in AILANG, PascalCase in Go)
		for fieldName, val := range updates {
			// Convert field name to PascalCase
			goFieldName := strings.ToUpper(fieldName[:1]) + fieldName[1:]
			field := newVal.FieldByName(goFieldName)
			if field.IsValid() && field.CanSet() {
				// Handle type conversion
				valReflect := reflect.ValueOf(val)
				if valReflect.Type().AssignableTo(field.Type()) {
					field.Set(valReflect)
				} else if valReflect.Kind() == reflect.Ptr && field.Kind() != reflect.Ptr {
					// M-DX20: Dereference pointer if field expects value type
					if valReflect.Elem().Type().AssignableTo(field.Type()) {
						field.Set(valReflect.Elem())
					}
				} else if valReflect.Kind() == reflect.Slice && field.Kind() == reflect.Slice {
					// M-DX19: Convert []interface{} to typed slice via reflection
					elemType := field.Type().Elem()
					newSlice := reflect.MakeSlice(field.Type(), valReflect.Len(), valReflect.Len())
					for i := 0; i < valReflect.Len(); i++ {
						elem := valReflect.Index(i)
						// Handle interface{} elements
						if elem.Kind() == reflect.Interface {
							elem = elem.Elem()
						}
						if elem.Type().AssignableTo(elemType) {
							newSlice.Index(i).Set(elem)
						} else if elem.Type().ConvertibleTo(elemType) {
							newSlice.Index(i).Set(elem.Convert(elemType))
						}
					}
					field.Set(newSlice)
				} else if valReflect.Type().ConvertibleTo(field.Type()) {
					field.Set(valReflect.Convert(field.Type()))
				} else {
					// Try to set directly for interface{} values
					field.Set(valReflect)
				}
			}
		}
		return newPtr.Interface()
	}

	// Fallback: create map from updates
	return updates
}

// FieldGet retrieves a field from a record (map or typed struct).
// M-DX18: Handles both map[string]interface{} and typed structs.
func FieldGet(record interface{}, field string) interface{} {
	// Handle map[string]interface{}
	if m, ok := record.(map[string]interface{}); ok {
		return m[field]
	}

	// Handle typed struct using reflection
	val := reflect.ValueOf(record)
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	if val.Kind() == reflect.Struct {
		// Convert field name to PascalCase (AILANG lowercase -> Go PascalCase)
		goField := strings.ToUpper(field[:1]) + field[1:]
		f := val.FieldByName(goField)
		if f.IsValid() {
			// M-DX21: Return pointer for struct-typed fields (AILANG expects *Struct)
			if f.Kind() == reflect.Struct && f.CanAddr() {
				return f.Addr().Interface()
			}
			return f.Interface()
		}
	}
	return nil
}

// Cons prepends an element to a list (cons operator).
// AILANG: head :: tail
func Cons(head interface{}, tail interface{}) []interface{} {
	if tail == nil {
		return []interface{}{head}
	}
	list, ok := tail.([]interface{})
	if !ok {
		return []interface{}{head}
	}
	return append([]interface{}{head}, list...)
}

// ListHead returns the first element of a list.
// Handles both []interface{} and typed slices via reflection.
func ListHead(list interface{}) interface{} {
	// Fast path for []interface{}
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[0]
	}
	// Reflection path for typed slices (e.g., []*Tile)
	v := reflect.ValueOf(list)
	if v.Kind() == reflect.Slice && v.Len() > 0 {
		return v.Index(0).Interface()
	}
	return nil
}

// ListTail returns all but the first element of a list.
// Handles both []interface{} and typed slices via reflection.
func ListTail(list interface{}) interface{} {
	// Fast path for []interface{}
	if l, ok := list.([]interface{}); ok && len(l) > 0 {
		return l[1:]
	}
	// Reflection path for typed slices (e.g., []*Tile)
	v := reflect.ValueOf(list)
	if v.Kind() == reflect.Slice && v.Len() > 0 {
		return v.Slice(1, v.Len()).Interface()
	}
	return []interface{}{}
}

// ListLen returns the length of a list.
// Handles both []interface{} and typed slices via reflection.
func ListLen(list interface{}) int {
	// Fast path for []interface{}
	if l, ok := list.([]interface{}); ok {
		return len(l)
	}
	// Reflection path for typed slices (e.g., []*Tile)
	v := reflect.ValueOf(list)
	if v.Kind() == reflect.Slice {
		return v.Len()
	}
	return 0
}

// Concat concatenates two lists (++ operator).
func Concat(a, b interface{}) interface{} {
	if a == nil {
		return b
	}
	if b == nil {
		return a
	}
	sliceA, okA := a.([]interface{})
	sliceB, okB := b.([]interface{})
	if !okA || !okB {
		return nil
	}
	result := make([]interface{}, 0, len(sliceA)+len(sliceB))
	result = append(result, sliceA...)
	result = append(result, sliceB...)
	return result
}

// AddInt adds two integers.
func AddInt(a, b interface{}) interface{} {
	return toInt64(a) + toInt64(b)
}

// SubInt subtracts two integers.
func SubInt(a, b interface{}) interface{} {
	return toInt64(a) - toInt64(b)
}

// MulInt multiplies two integers.
func MulInt(a, b interface{}) interface{} {
	return toInt64(a) * toInt64(b)
}

// DivInt divides two integers.
func DivInt(a, b interface{}) interface{} {
	return toInt64(a) / toInt64(b)
}

// ModInt returns integer modulo.
func ModInt(a, b interface{}) interface{} {
	return toInt64(a) % toInt64(b)
}

// AddFloat adds two floats.
func AddFloat(a, b interface{}) interface{} {
	return toFloat64(a) + toFloat64(b)
}

// SubFloat subtracts two floats.
func SubFloat(a, b interface{}) interface{} {
	return toFloat64(a) - toFloat64(b)
}

// MulFloat multiplies two floats.
func MulFloat(a, b interface{}) interface{} {
	return toFloat64(a) * toFloat64(b)
}

// DivFloat divides two floats.
func DivFloat(a, b interface{}) interface{} {
	return toFloat64(a) / toFloat64(b)
}

// IntToFloat converts int to float.
func IntToFloat(a interface{}) interface{} {
	return float64(toInt64(a))
}

// FloatToInt converts float to int.
func FloatToInt(a interface{}) interface{} {
	return int64(toFloat64(a))
}

// EqInt compares two integers for equality.
func EqInt(a, b interface{}) interface{} {
	return toInt64(a) == toInt64(b)
}

// LtInt compares two integers (less than).
func LtInt(a, b interface{}) interface{} {
	return toInt64(a) < toInt64(b)
}

// LeInt compares two integers (less or equal).
func LeInt(a, b interface{}) interface{} {
	return toInt64(a) <= toInt64(b)
}

// GtInt compares two integers (greater than).
func GtInt(a, b interface{}) interface{} {
	return toInt64(a) > toInt64(b)
}

// GeInt compares two integers (greater or equal).
func GeInt(a, b interface{}) interface{} {
	return toInt64(a) >= toInt64(b)
}

// NegInt negates an integer.
func NegInt(a interface{}) interface{} {
	return -toInt64(a)
}

// NegFloat negates a float.
func NegFloat(a interface{}) interface{} {
	return -toFloat64(a)
}

// LtFloat compares two floats (less than).
func LtFloat(a, b interface{}) interface{} {
	return toFloat64(a) < toFloat64(b)
}

// LeFloat compares two floats (less or equal).
func LeFloat(a, b interface{}) interface{} {
	return toFloat64(a) <= toFloat64(b)
}

// GtFloat compares two floats (greater than).
func GtFloat(a, b interface{}) interface{} {
	return toFloat64(a) > toFloat64(b)
}

// GeFloat compares two floats (greater or equal).
func GeFloat(a, b interface{}) interface{} {
	return toFloat64(a) >= toFloat64(b)
}

// toInt64 converts interface{} to int64.
func toInt64(v interface{}) int64 {
	switch x := v.(type) {
	case int64:
		return x
	case int:
		return int64(x)
	case float64:
		return int64(x)
	default:
		return 0
	}
}

// toFloat64 converts interface{} to float64.
func toFloat64(v interface{}) float64 {
	switch x := v.(type) {
	case float64:
		return x
	case int64:
		return float64(x)
	case int:
		return float64(x)
	default:
		return 0
	}
}

// CallFunc calls an interface{} as a function with the given arguments.
// Used for lambdas stored in variables.
func CallFunc(f interface{}, args ...interface{}) interface{} {
	switch fn := f.(type) {
	case func() interface{}:
		return fn()
	case func(interface{}) interface{}:
		if len(args) >= 1 {
			return fn(args[0])
		}
	case func(interface{}, interface{}) interface{}:
		if len(args) >= 2 {
			return fn(args[0], args[1])
		}
	case func(interface{}, interface{}, interface{}) interface{}:
		if len(args) >= 3 {
			return fn(args[0], args[1], args[2])
		}
	case func(...interface{}) interface{}:
		return fn(args...)
	}
	panic("CallFunc: unsupported function type")
}

// Show converts any value to its string representation.
func Show(v interface{}) string {
	switch x := v.(type) {
	case string:
		return x
	case int64:
		return fmt.Sprintf("%d", x)
	case int:
		return fmt.Sprintf("%d", x)
	case float64:
		return fmt.Sprintf("%g", x)
	case bool:
		if x {
			return "true"
		}
		return "false"
	case nil:
		return "()"
	default:
		return fmt.Sprintf("%v", x)
	}
}

// ConcatString concatenates two values as strings.
func ConcatString(a, b interface{}) string {
	return fmt.Sprintf("%v%v", a, b)
}

// Log prints a message and returns unit.
func Log(msg interface{}) interface{} {
	fmt.Println(msg)
	return struct{}{}
}

// Debug prints a debug message and returns unit.
func Debug(msg interface{}) interface{} {
	fmt.Printf("[DEBUG] %v\n", msg)
	return struct{}{}
}

// ConvertToInt64Slice converts []interface{} to []int64.
func ConvertToInt64Slice(v interface{}) []int64 {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]int64, len(slice))
	for i, elem := range slice {
		result[i] = toInt64(elem)
	}
	return result
}

// ConvertToStringSlice converts []interface{} to []string.
func ConvertToStringSlice(v interface{}) []string {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]string, len(slice))
	for i, elem := range slice {
		if s, ok := elem.(string); ok {
			result[i] = s
		}
	}
	return result
}

// ConvertToRecordSlice converts []interface{} to []map[string]interface{}.
func ConvertToRecordSlice(v interface{}) []map[string]interface{} {
	if v == nil {
		return nil
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]map[string]interface{}, len(slice))
	for i, elem := range slice {
		if m, ok := elem.(map[string]interface{}); ok {
			result[i] = m
		}
	}
	return result
}

// ConvertToBoolSlice converts []interface{} to []bool.
func ConvertToBoolSlice(v interface{}) []bool {
	if v == nil {
		return nil
	}
	// Passthrough if already []bool
	if bs, ok := v.([]bool); ok {
		return bs
	}
	slice, ok := v.([]interface{})
	if !ok {
		return nil
	}
	result := make([]bool, len(slice))
	for i, elem := range slice {
		if b, ok := elem.(bool); ok {
			result[i] = b
		}
	}
	return result
}

// FromList creates an array from a list.
// In Go, both arrays and lists are []interface{}.
func FromList(xs interface{}) interface{} {
	if xs == nil {
		return []interface{}{}
	}
	// Fast path for []interface{}
	if list, ok := xs.([]interface{}); ok {
		// Return a copy to preserve immutability
		result := make([]interface{}, len(list))
		copy(result, list)
		return result
	}
	// Reflection path for typed slices (e.g., []int64, []*Tile)
	v := reflect.ValueOf(xs)
	if v.Kind() == reflect.Slice {
		result := make([]interface{}, v.Len())
		for i := 0; i < v.Len(); i++ {
			result[i] = v.Index(i).Interface()
		}
		return result
	}
	return []interface{}{}
}

// ToList converts an array to a list.
// In Go, both are []interface{}, so this is essentially identity.
func ToList(arr interface{}) interface{} {
	if arr == nil {
		return []interface{}{}
	}
	// Fast path for []interface{}
	if slice, ok := arr.([]interface{}); ok {
		result := make([]interface{}, len(slice))
		copy(result, slice)
		return result
	}
	// Reflection path for typed slices (e.g., []int64, []*Tile)
	v := reflect.ValueOf(arr)
	if v.Kind() == reflect.Slice {
		result := make([]interface{}, v.Len())
		for i := 0; i < v.Len(); i++ {
			result[i] = v.Index(i).Interface()
		}
		return result
	}
	return []interface{}{}
}

// Length returns the length of an array.
func Length(arr interface{}) interface{} {
	if arr == nil {
		return int64(0)
	}
	// Fast path for []interface{}
	if slice, ok := arr.([]interface{}); ok {
		return int64(len(slice))
	}
	// Reflection path for typed slices (e.g., []int64, []*Tile)
	v := reflect.ValueOf(arr)
	if v.Kind() == reflect.Slice {
		return int64(v.Len())
	}
	return int64(0)
}

// Get returns the element at the given index.
// Panics if index is out of bounds.
func Get(arr interface{}, idx interface{}) interface{} {
	i := toInt64(idx)
	// Fast path for []interface{}
	if slice, ok := arr.([]interface{}); ok {
		if i < 0 || i >= int64(len(slice)) {
			panic(fmt.Sprintf("array index out of bounds: %d (length %d)", i, len(slice)))
		}
		return slice[i]
	}
	// Reflection path for typed slices (e.g., []int64, []*Tile)
	v := reflect.ValueOf(arr)
	if v.Kind() == reflect.Slice {
		if i < 0 || i >= int64(v.Len()) {
			panic(fmt.Sprintf("array index out of bounds: %d (length %d)", i, v.Len()))
		}
		return v.Index(int(i)).Interface()
	}
	panic("Get: not an array")
}

// GetOpt safely returns the element at index, or None if out of bounds.
// Returns Some(element) or None. Uses makeOptionSome/makeOptionNone helpers
// which delegate to typed constructors if Option ADT is present.
func GetOpt(arr interface{}, idx interface{}) interface{} {
	i := toInt64(idx)
	if i < 0 {
		return makeOptionNone()
	}
	if slice, ok := arr.([]interface{}); ok {
		if i >= int64(len(slice)) {
			return makeOptionNone()
		}
		return makeOptionSome(slice[i])
	}
	// Reflection path for typed slices (e.g., []int64, []*Tile)
	v := reflect.ValueOf(arr)
	if v.Kind() == reflect.Slice {
		if i >= int64(v.Len()) {
			return makeOptionNone()
		}
		return makeOptionSome(v.Index(int(i)).Interface())
	}
	return makeOptionNone()
}

// makeOptionSome creates a Some value.
// Uses map-based representation for runtime compatibility.
func makeOptionSome(v interface{}) interface{} {
	return map[string]interface{}{"_tag": "Some", "value": v}
}

// makeOptionNone creates a None value.
// Uses map-based representation for runtime compatibility.
func makeOptionNone() interface{} {
	return map[string]interface{}{"_tag": "None"}
}

// UnsafeGet returns element at index without bounds checking.
// Caller must ensure index is valid.
func UnsafeGet(arr interface{}, idx interface{}) interface{} {
	i := toInt64(idx)
	if slice, ok := arr.([]interface{}); ok {
		return slice[i]
	}
	panic("UnsafeGet: not an array")
}

// Set returns a new array with the element at index updated.
// Preserves immutability by creating a copy.
func Set(arr interface{}, idx interface{}, val interface{}) interface{} {
	i := toInt64(idx)
	if slice, ok := arr.([]interface{}); ok {
		if i < 0 || i >= int64(len(slice)) {
			panic(fmt.Sprintf("array index out of bounds: %d (length %d)", i, len(slice)))
		}
		result := make([]interface{}, len(slice))
		copy(result, slice)
		result[i] = val
		return result
	}
	panic("Set: not an array")
}

// Make creates an array of given size with all elements set to default.
func Make(size interface{}, defaultVal interface{}) interface{} {
	n := toInt64(size)
	if n < 0 {
		n = 0
	}
	result := make([]interface{}, n)
	for i := range result {
		result[i] = defaultVal
	}
	return result
}

// ConvertToArrivalPhaseSlice converts []interface{} to []*ArrivalPhase.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToArrivalPhaseSlice(v interface{}) []*ArrivalPhase {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToArrivalPhaseSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ArrivalPhase{}
	}
	out := make([]*ArrivalPhase, len(src))
	for i, e := range src {
		elem, ok := e.(*ArrivalPhase)
		if !ok {
			panic(fmt.Sprintf("ConvertToArrivalPhaseSlice: element %d: expected *ArrivalPhase, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToBridgeInputResultSlice converts []interface{} to []*BridgeInputResult.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToBridgeInputResultSlice(v interface{}) []*BridgeInputResult {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToBridgeInputResultSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*BridgeInputResult{}
	}
	out := make([]*BridgeInputResult, len(src))
	for i, e := range src {
		elem, ok := e.(*BridgeInputResult)
		if !ok {
			panic(fmt.Sprintf("ConvertToBridgeInputResultSlice: element %d: expected *BridgeInputResult, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToBridgeStationSlice converts []interface{} to []*BridgeStation.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToBridgeStationSlice(v interface{}) []*BridgeStation {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToBridgeStationSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*BridgeStation{}
	}
	out := make([]*BridgeStation, len(src))
	for i, e := range src {
		elem, ok := e.(*BridgeStation)
		if !ok {
			panic(fmt.Sprintf("ConvertToBridgeStationSlice: element %d: expected *BridgeStation, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToCelestialPlanetSlice converts []interface{} to []*CelestialPlanet.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToCelestialPlanetSlice(v interface{}) []*CelestialPlanet {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToCelestialPlanetSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*CelestialPlanet{}
	}
	out := make([]*CelestialPlanet, len(src))
	for i, e := range src {
		elem, ok := e.(*CelestialPlanet)
		if !ok {
			panic(fmt.Sprintf("ConvertToCelestialPlanetSlice: element %d: expected *CelestialPlanet, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToClickKindSlice converts []interface{} to []*ClickKind.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToClickKindSlice(v interface{}) []*ClickKind {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToClickKindSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ClickKind{}
	}
	out := make([]*ClickKind, len(src))
	for i, e := range src {
		elem, ok := e.(*ClickKind)
		if !ok {
			panic(fmt.Sprintf("ConvertToClickKindSlice: element %d: expected *ClickKind, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToConsoleStateSlice converts []interface{} to []*ConsoleState.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToConsoleStateSlice(v interface{}) []*ConsoleState {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToConsoleStateSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ConsoleState{}
	}
	out := make([]*ConsoleState, len(src))
	for i, e := range src {
		elem, ok := e.(*ConsoleState)
		if !ok {
			panic(fmt.Sprintf("ConvertToConsoleStateSlice: element %d: expected *ConsoleState, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToCrewActivitySlice converts []interface{} to []*CrewActivity.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToCrewActivitySlice(v interface{}) []*CrewActivity {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToCrewActivitySlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*CrewActivity{}
	}
	out := make([]*CrewActivity, len(src))
	for i, e := range src {
		elem, ok := e.(*CrewActivity)
		if !ok {
			panic(fmt.Sprintf("ConvertToCrewActivitySlice: element %d: expected *CrewActivity, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToCrewPositionSlice converts []interface{} to []*CrewPosition.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToCrewPositionSlice(v interface{}) []*CrewPosition {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToCrewPositionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*CrewPosition{}
	}
	out := make([]*CrewPosition, len(src))
	for i, e := range src {
		elem, ok := e.(*CrewPosition)
		if !ok {
			panic(fmt.Sprintf("ConvertToCrewPositionSlice: element %d: expected *CrewPosition, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToCurrentPlanetSlice converts []interface{} to []*CurrentPlanet.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToCurrentPlanetSlice(v interface{}) []*CurrentPlanet {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToCurrentPlanetSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*CurrentPlanet{}
	}
	out := make([]*CurrentPlanet, len(src))
	for i, e := range src {
		elem, ok := e.(*CurrentPlanet)
		if !ok {
			panic(fmt.Sprintf("ConvertToCurrentPlanetSlice: element %d: expected *CurrentPlanet, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToDeckTypeSlice converts []interface{} to []*DeckType.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToDeckTypeSlice(v interface{}) []*DeckType {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToDeckTypeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*DeckType{}
	}
	out := make([]*DeckType, len(src))
	for i, e := range src {
		elem, ok := e.(*DeckType)
		if !ok {
			panic(fmt.Sprintf("ConvertToDeckTypeSlice: element %d: expected *DeckType, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToDepthLayerSlice converts []interface{} to []*DepthLayer.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToDepthLayerSlice(v interface{}) []*DepthLayer {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToDepthLayerSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*DepthLayer{}
	}
	out := make([]*DepthLayer, len(src))
	for i, e := range src {
		elem, ok := e.(*DepthLayer)
		if !ok {
			panic(fmt.Sprintf("ConvertToDepthLayerSlice: element %d: expected *DepthLayer, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToDirectionSlice converts []interface{} to []*Direction.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToDirectionSlice(v interface{}) []*Direction {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToDirectionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Direction{}
	}
	out := make([]*Direction, len(src))
	for i, e := range src {
		elem, ok := e.(*Direction)
		if !ok {
			panic(fmt.Sprintf("ConvertToDirectionSlice: element %d: expected *Direction, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToDrawCmdSlice converts []interface{} to []*DrawCmd.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToDrawCmdSlice(v interface{}) []*DrawCmd {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToDrawCmdSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*DrawCmd{}
	}
	out := make([]*DrawCmd, len(src))
	for i, e := range src {
		elem, ok := e.(*DrawCmd)
		if !ok {
			panic(fmt.Sprintf("ConvertToDrawCmdSlice: element %d: expected *DrawCmd, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToInteractableIDSlice converts []interface{} to []*InteractableID.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToInteractableIDSlice(v interface{}) []*InteractableID {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToInteractableIDSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*InteractableID{}
	}
	out := make([]*InteractableID, len(src))
	for i, e := range src {
		elem, ok := e.(*InteractableID)
		if !ok {
			panic(fmt.Sprintf("ConvertToInteractableIDSlice: element %d: expected *InteractableID, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToKeyEventSlice converts []interface{} to []*KeyEvent.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToKeyEventSlice(v interface{}) []*KeyEvent {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToKeyEventSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*KeyEvent{}
	}
	out := make([]*KeyEvent, len(src))
	for i, e := range src {
		elem, ok := e.(*KeyEvent)
		if !ok {
			panic(fmt.Sprintf("ConvertToKeyEventSlice: element %d: expected *KeyEvent, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToMoveStateSlice converts []interface{} to []*MoveState.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToMoveStateSlice(v interface{}) []*MoveState {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToMoveStateSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*MoveState{}
	}
	out := make([]*MoveState, len(src))
	for i, e := range src {
		elem, ok := e.(*MoveState)
		if !ok {
			panic(fmt.Sprintf("ConvertToMoveStateSlice: element %d: expected *MoveState, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToMovementPatternSlice converts []interface{} to []*MovementPattern.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToMovementPatternSlice(v interface{}) []*MovementPattern {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToMovementPatternSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*MovementPattern{}
	}
	out := make([]*MovementPattern, len(src))
	for i, e := range src {
		elem, ok := e.(*MovementPattern)
		if !ok {
			panic(fmt.Sprintf("ConvertToMovementPatternSlice: element %d: expected *MovementPattern, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToNPCSlice converts []interface{} to []*NPC.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToNPCSlice(v interface{}) []*NPC {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToNPCSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*NPC{}
	}
	out := make([]*NPC, len(src))
	for i, e := range src {
		elem, ok := e.(*NPC)
		if !ok {
			panic(fmt.Sprintf("ConvertToNPCSlice: element %d: expected *NPC, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToOptionSlice converts []interface{} to []*Option.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToOptionSlice(v interface{}) []*Option {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToOptionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Option{}
	}
	out := make([]*Option, len(src))
	for i, e := range src {
		elem, ok := e.(*Option)
		if !ok {
			panic(fmt.Sprintf("ConvertToOptionSlice: element %d: expected *Option, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToPlanetTypeSlice converts []interface{} to []*PlanetType.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToPlanetTypeSlice(v interface{}) []*PlanetType {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToPlanetTypeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*PlanetType{}
	}
	out := make([]*PlanetType, len(src))
	for i, e := range src {
		elem, ok := e.(*PlanetType)
		if !ok {
			panic(fmt.Sprintf("ConvertToPlanetTypeSlice: element %d: expected *PlanetType, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToPlayerActionSlice converts []interface{} to []*PlayerAction.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToPlayerActionSlice(v interface{}) []*PlayerAction {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToPlayerActionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*PlayerAction{}
	}
	out := make([]*PlayerAction, len(src))
	for i, e := range src {
		elem, ok := e.(*PlayerAction)
		if !ok {
			panic(fmt.Sprintf("ConvertToPlayerActionSlice: element %d: expected *PlayerAction, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToSelectionSlice converts []interface{} to []*Selection.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToSelectionSlice(v interface{}) []*Selection {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToSelectionSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Selection{}
	}
	out := make([]*Selection, len(src))
	for i, e := range src {
		elem, ok := e.(*Selection)
		if !ok {
			panic(fmt.Sprintf("ConvertToSelectionSlice: element %d: expected *Selection, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToSpectralTypeSlice converts []interface{} to []*SpectralType.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToSpectralTypeSlice(v interface{}) []*SpectralType {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToSpectralTypeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*SpectralType{}
	}
	out := make([]*SpectralType, len(src))
	for i, e := range src {
		elem, ok := e.(*SpectralType)
		if !ok {
			panic(fmt.Sprintf("ConvertToSpectralTypeSlice: element %d: expected *SpectralType, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToStarSlice converts []interface{} to []*Star.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToStarSlice(v interface{}) []*Star {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToStarSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Star{}
	}
	out := make([]*Star, len(src))
	for i, e := range src {
		elem, ok := e.(*Star)
		if !ok {
			panic(fmt.Sprintf("ConvertToStarSlice: element %d: expected *Star, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToStarTypeSlice converts []interface{} to []*StarType.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToStarTypeSlice(v interface{}) []*StarType {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToStarTypeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*StarType{}
	}
	out := make([]*StarType, len(src))
	for i, e := range src {
		elem, ok := e.(*StarType)
		if !ok {
			panic(fmt.Sprintf("ConvertToStarTypeSlice: element %d: expected *StarType, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToStructureTypeSlice converts []interface{} to []*StructureType.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToStructureTypeSlice(v interface{}) []*StructureType {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToStructureTypeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*StructureType{}
	}
	out := make([]*StructureType, len(src))
	for i, e := range src {
		elem, ok := e.(*StructureType)
		if !ok {
			panic(fmt.Sprintf("ConvertToStructureTypeSlice: element %d: expected *StructureType, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToTileSlice converts []interface{} to []*Tile.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToTileSlice(v interface{}) []*Tile {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToTileSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*Tile{}
	}
	out := make([]*Tile, len(src))
	for i, e := range src {
		elem, ok := e.(*Tile)
		if !ok {
			panic(fmt.Sprintf("ConvertToTileSlice: element %d: expected *Tile, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToTransitionStateSlice converts []interface{} to []*TransitionState.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToTransitionStateSlice(v interface{}) []*TransitionState {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToTransitionStateSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*TransitionState{}
	}
	out := make([]*TransitionState, len(src))
	for i, e := range src {
		elem, ok := e.(*TransitionState)
		if !ok {
			panic(fmt.Sprintf("ConvertToTransitionStateSlice: element %d: expected *TransitionState, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToUiKindSlice converts []interface{} to []*UiKind.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToUiKindSlice(v interface{}) []*UiKind {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToUiKindSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*UiKind{}
	}
	out := make([]*UiKind, len(src))
	for i, e := range src {
		elem, ok := e.(*UiKind)
		if !ok {
			panic(fmt.Sprintf("ConvertToUiKindSlice: element %d: expected *UiKind, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToViewModeSlice converts []interface{} to []*ViewMode.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToViewModeSlice(v interface{}) []*ViewMode {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToViewModeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ViewMode{}
	}
	out := make([]*ViewMode, len(src))
	for i, e := range src {
		elem, ok := e.(*ViewMode)
		if !ok {
			panic(fmt.Sprintf("ConvertToViewModeSlice: element %d: expected *ViewMode, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToViewportContentSlice converts []interface{} to []*ViewportContent.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToViewportContentSlice(v interface{}) []*ViewportContent {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToViewportContentSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ViewportContent{}
	}
	out := make([]*ViewportContent, len(src))
	for i, e := range src {
		elem, ok := e.(*ViewportContent)
		if !ok {
			panic(fmt.Sprintf("ConvertToViewportContentSlice: element %d: expected *ViewportContent, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToViewportEffectSlice converts []interface{} to []*ViewportEffect.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToViewportEffectSlice(v interface{}) []*ViewportEffect {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToViewportEffectSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ViewportEffect{}
	}
	out := make([]*ViewportEffect, len(src))
	for i, e := range src {
		elem, ok := e.(*ViewportEffect)
		if !ok {
			panic(fmt.Sprintf("ConvertToViewportEffectSlice: element %d: expected *ViewportEffect, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}

// ConvertToViewportShapeSlice converts []interface{} to []*ViewportShape.
// M-DX12: Fail-fast - panics on type mismatch (compiler bug detection).
func ConvertToViewportShapeSlice(v interface{}) []*ViewportShape {
	if v == nil {
		return nil
	}
	src, ok := v.([]interface{})
	if !ok {
		panic(fmt.Sprintf("ConvertToViewportShapeSlice: expected []interface{}, got %T", v))
	}
	if len(src) == 0 {
		return []*ViewportShape{}
	}
	out := make([]*ViewportShape, len(src))
	for i, e := range src {
		elem, ok := e.(*ViewportShape)
		if !ok {
			panic(fmt.Sprintf("ConvertToViewportShapeSlice: element %d: expected *ViewportShape, got %T", i, e))
		}
		out[i] = elem
	}
	return out
}
