//kage:unit pixels
package main

// Special Relativity visual effects shader
// Implements: Aberration, Doppler shift, Relativistic beaming (D³)
//
// Physics formulas used:
// - Aberration: cos(θ) = (cos(θ') + β) / (1 + β·cos(θ'))
// - Doppler: D = γ(1 + β·cos(θ))
// - Beaming: I' = I × D³
//
// ViewAngle: angle from velocity direction to view center
// - ViewAngle = 0: looking forward (in direction of motion)
// - ViewAngle = π/2: looking perpendicular to motion
// - ViewAngle = π: looking backward (opposite to motion)

var BetaX float     // Velocity X component (usually 0)
var BetaY float     // Velocity Y component (usually 0)
var BetaZ float     // Velocity Z component (forward velocity)
var Gamma float     // Lorentz factor: 1/sqrt(1-|beta|^2)
var FOV float       // Field of view in radians (not currently used)
var ViewAngle float // Viewing angle: 0=front, π/2=side, π=back

func Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {
	size := imageDstSize()

	// Get velocity magnitude
	beta := vec3(BetaX, BetaY, BetaZ)
	betaMag := length(beta)

	// No transform if stationary or very slow (below 0.05c)
	if betaMag < 0.05 {
		return imageSrc0At(srcPos)
	}

	// Screen coordinates relative to center
	center := size / 2.0
	offset := srcPos - center
	maxDist := length(center)
	dist := length(offset) / maxDist // 0 at center, 1 at edge
	pixelAngle := atan2(offset.y, offset.x) // Angle around screen center

	// Half field of view (radians) - approximately 57 degrees
	halfFOV := 1.0

	// === APPARENT ANGLE (θ') ===
	// The screen shows a cone of directions centered at ViewAngle from velocity.
	// The radial distance from screen center maps to angular distance from ViewAngle.
	//
	// For ViewAngle = 0 (forward): center is θ' = 0, edges are θ' = halfFOV
	// For ViewAngle = π (behind): center is θ' = π, edges are θ' = π - halfFOV
	//
	// Key insight: aberration is radially symmetric around the velocity axis,
	// so we use radial screen distance to map to angle.

	thetaPrime := ViewAngle + dist * halfFOV

	// Clamp to valid physical range [0, π]
	thetaPrime = clamp(thetaPrime, 0.001, 3.14159)

	// === EXACT RELATIVISTIC ABERRATION ===
	// Formula: cos(θ) = (cos(θ') + β) / (1 + β·cos(θ'))
	// θ' = apparent angle (where we're looking in moving frame)
	// θ = true angle (where light came from in rest frame)
	cosThetaPrime := cos(thetaPrime)
	cosTheta := (cosThetaPrime + betaMag) / (1.0 + betaMag * cosThetaPrime)
	cosTheta = clamp(cosTheta, -1.0, 1.0)
	theta := acos(cosTheta)

	// === SAMPLE POSITION ===
	// Convert true angle back to where we should sample in the source image.
	// The source image is rendered without aberration, centered at ViewAngle.
	//
	// deltaTheta = how far the true direction is from our view center
	deltaTheta := theta - ViewAngle

	// Normalize to screen distance (0 = center, 1 = edge in source)
	sampleDist := deltaTheta / halfFOV

	// Clamp for sampling - but track if out of bounds for fading
	isOutOfBounds := sampleDist > 1.5 || sampleDist < -0.5
	sampleDistClamped := clamp(sampleDist, 0.0, 1.4)

	// Reconstruct sample position (radial from center, same angle around center)
	newOffset := vec2(
		cos(pixelAngle) * sampleDistClamped * maxDist,
		sin(pixelAngle) * sampleDistClamped * maxDist,
	)
	samplePos := center + newOffset

	// Clamp to image bounds
	samplePos.x = clamp(samplePos.x, 0.0, size.x - 1.0)
	samplePos.y = clamp(samplePos.y, 0.0, size.y - 1.0)

	// Sample the source image
	c := imageSrc0At(samplePos)

	// Fade out-of-bounds areas
	if isOutOfBounds {
		fade := clamp((max(sampleDist - 1.2, -0.3 - sampleDist)) * 1.5, 0.0, 0.7)
		c.rgb *= (1.0 - fade)
	}

	// === DOPPLER SHIFT ===
	// D = γ(1 + β·cos(θ)) where θ is the TRUE angle from velocity
	// D > 1: blueshift (approaching light), D < 1: redshift (receding light)
	D := Gamma * (1.0 + betaMag * cosTheta)
	D = clamp(D, 0.05, 15.0)

	// Apply color shift based on Doppler factor
	if D > 1.0 {
		// Blueshift - shift spectrum toward blue/violet
		shift := (D - 1.0) * 0.25
		shift = clamp(shift, 0.0, 0.85)
		c.r *= (1.0 - shift * 0.6)
		c.g *= (1.0 - shift * 0.25)
		c.b = clamp(c.b * (1.0 + shift * 0.5), 0.0, 1.0)
	} else {
		// Redshift - shift spectrum toward red
		shift := (1.0 - D) * 0.4
		shift = clamp(shift, 0.0, 0.9)
		c.r = clamp(c.r * (1.0 + shift * 0.6), 0.0, 1.0)
		c.g *= (1.0 - shift * 0.35)
		c.b *= (1.0 - shift * 0.6)
	}

	// === RELATIVISTIC BEAMING (D³) ===
	// Intensity transforms as I' = I × D³
	// This creates the "headlight effect" - objects ahead appear brighter
	beamFactor := D * D * D
	beamFactor = clamp(beamFactor, 0.08, 6.0) // Allow dimming but not total darkness

	c.rgb *= beamFactor

	// Final clamp
	c.rgb = clamp(c.rgb, vec3(0.0), vec3(1.0))

	return c
}
