//kage:unit pixels
package main

// General Relativity gravitational lensing shader
// Implements EXACT Schwarzschild weak-field lensing: α(b) = 2r_s/b
//
// Physics formulas (all exact):
// - Deflection angle: α = 2r_s/b (Einstein's weak-field formula)
// - Impact parameter: b = perpendicular distance from ray to object
// - Event horizon: r = r_s (Schwarzschild radius)
// - Photon sphere: r = 1.5 r_s (light can orbit here)
//
// This shader distorts the image radially around a massive object,
// simulating how gravity bends light paths toward the mass.

// Screen-space center of the massive object (normalized 0-1)
var CenterX float
var CenterY float

// Schwarzschild radius in screen-normalized units
var Rs float

// Dimensionless potential Phi = r_s/(2r) - measures GR severity
var Phi float

// Unused (kept for uniform compatibility)
var LensStrength float

// Maximum effect radius (normalized) - beyond this, no distortion
var MaxEffectRadius float

// Redshift factor (unused here, passed to redshift shader)
var RedshiftFactor float

func Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {
	size := imageDstSize()

	// Convert to normalized coordinates (0-1)
	uv := srcPos / size

	// Vector from pixel to massive object center
	center := vec2(CenterX, CenterY)
	toCenter := center - uv

	// Distance from massive object (in normalized screen space)
	dist := length(toCenter)

	// === EVENT HORIZON (EXACT: r = r_s) ===
	// Inside Schwarzschild radius, nothing escapes - render black
	if dist < Rs {
		return vec4(0.0, 0.0, 0.0, 1.0)
	}

	// Skip if outside effect radius (performance optimization)
	if dist > MaxEffectRadius {
		return imageSrc0At(srcPos)
	}

	// Normalize direction toward center
	dir := toCenter / dist

	// === GRAVITATIONAL LENSING (EXACT WEAK-FIELD) ===
	// Einstein's deflection formula: α = 2 * r_s / b
	// where b is the impact parameter (distance from ray to object)
	// In screen space, b = dist

	// Exact deflection angle (in radians, but we use as displacement)
	// α = 2 * Rs / dist
	deflection := 2.0 * Rs / dist

	// Apply smooth falloff at max radius for visual quality
	// (not physics, just prevents hard edge artifacts)
	falloff := 1.0 - smoothstep(MaxEffectRadius * 0.8, MaxEffectRadius, dist)
	deflection *= falloff

	// Clamp to prevent extreme warping at photon sphere
	// (real ray-tracing would show multiple images here)
	deflection = clamp(deflection, 0.0, 0.3)

	// Displace UV toward the center (light bends toward mass)
	newUV := uv + dir * deflection

	// Convert back to pixel coordinates
	samplePos := newUV * size

	// Bounds check
	if samplePos.x < 0.0 || samplePos.x >= size.x || samplePos.y < 0.0 || samplePos.y >= size.y {
		return vec4(0.0, 0.0, 0.0, 1.0)
	}

	// Sample the distorted position
	c := imageSrc0At(samplePos)

	// === PHOTON SPHERE (EXACT: r = 1.5 r_s) ===
	// At 1.5 * Rs, light orbits the black hole
	// Increase lensing intensity here (multiple images would overlap)
	// No artificial glow - just enhanced distortion sampling
	photonDist := 1.5 * Rs
	if dist < photonDist * 1.2 && dist > Rs {
		// Near photon sphere: sample multiple offset positions
		// to simulate light wrapping around (simplified)
		offset1 := dir * deflection * 0.5
		offset2 := dir * deflection * 1.5
		c1 := imageSrc0At((uv + offset1) * size)
		c2 := imageSrc0At((uv + offset2) * size)
		// Blend for softer transition
		blend := smoothstep(Rs, photonDist, dist)
		c = mix(c, (c + c1 + c2) / 3.0, (1.0 - blend) * 0.3)
	}

	return c
}
