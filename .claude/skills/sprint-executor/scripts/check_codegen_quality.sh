#!/bin/bash
# Check AILANG-generated Go code for quality issues
# Reports excessive nesting, closure wrapping, and other codegen patterns
# that may indicate AILANG compiler issues
#
# IMPORTANT: This script should catch codegen bugs BEFORE attempting go build
# so we can report to AILANG team instead of implementing workarounds.

set -e

SIM_GEN_DIR="${1:-sim_gen}"
NESTING_THRESHOLD="${2:-20}"  # Max acceptable nesting depth
CLOSURE_THRESHOLD="${3:-10}" # Max acceptable consecutive closure wrappers

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

echo "=== AILANG Codegen Quality Check ==="
echo "Directory: $SIM_GEN_DIR"
echo "Nesting threshold: $NESTING_THRESHOLD levels"
echo ""

issues_found=0
codegen_bugs=""

# Check each generated .go file
for file in "$SIM_GEN_DIR"/*.go; do
    [ -f "$file" ] || continue

    # Skip non-generated files
    if ! head -1 "$file" | grep -q "Code generated by ailang"; then
        continue
    fi

    filename=$(basename "$file")

    # Measure max indentation depth (tabs/spaces -> nesting level)
    max_indent=$(awk '{
        match($0, /^[\t ]+/)
        indent = RLENGTH
        if (indent > max) max = indent
    }
    END { print (max > 0 ? max : 0) }' "$file")
    max_indent=${max_indent:-0}

    # Count closure wrapper patterns: "return func() interface{} {"
    closure_count=$(grep -c "return func() interface{}" "$file" 2>/dev/null || true)
    closure_count=${closure_count:-0}

    # Count consecutive closure wrappers (indicates poor flattening)
    max_consecutive=$(awk '
        /return func\(\) interface\{\}/ { count++; if (count > max) max = count; next }
        /^[^}]/ { count = 0 }
        END { print (max > 0 ? max : 0) }
    ' "$file")
    max_consecutive=${max_consecutive:-0}

    # Count unnecessary suppress unused patterns
    suppress_count=$(grep -c '_ = .* // suppress unused' "$file" 2>/dev/null || true)
    suppress_count=${suppress_count:-0}

    # Check for multiple default cases in switch (codegen bug indicator)
    multi_default=$(grep -n "default:" "$file" 2>/dev/null | awk -F: '{print $1}' | sort -n | uniq -d | wc -l || true)
    multi_default=$((multi_default + 0))

    # Check for multiple defaults in same switch block
    multi_default_in_switch=$(awk '
        /switch/ { in_switch=1; default_count=0 }
        in_switch && /default:/ { default_count++ }
        in_switch && default_count > 1 { found=1 }
        /^[[:space:]]*\}[[:space:]]*\(\)/ { in_switch=0; default_count=0 }
        END { print (found ? 1 : 0) }
    ' "$file")
    multi_default_in_switch=${multi_default_in_switch:-0}

    # Report findings for this file
    file_has_issues=0

    # Ensure we have valid integers for comparison
    max_indent=$((max_indent + 0))
    max_consecutive=$((max_consecutive + 0))
    closure_count=$((closure_count + 0))
    suppress_count=$((suppress_count + 0))

    if [ "$max_indent" -gt "$NESTING_THRESHOLD" ]; then
        echo -e "${RED}[NESTING]${NC} $filename: max indent $max_indent chars (threshold: $NESTING_THRESHOLD)"
        file_has_issues=1
        issues_found=$((issues_found + 1))
    fi

    if [ "$max_consecutive" -gt "$CLOSURE_THRESHOLD" ]; then
        echo -e "${RED}[CLOSURES]${NC} $filename: $max_consecutive consecutive closure wrappers (threshold: $CLOSURE_THRESHOLD)"
        file_has_issues=1
        issues_found=$((issues_found + 1))
    fi

    if [ "$multi_default_in_switch" -gt 0 ]; then
        echo -e "${RED}[CODEGEN BUG]${NC} $filename: multiple default cases in switch statement"
        file_has_issues=1
        issues_found=$((issues_found + 1))
        codegen_bugs="${codegen_bugs}  - $filename: multiple default cases in switch (tuple pattern matching bug?)\n"
    fi

    if [ "$closure_count" -gt 50 ]; then
        echo -e "${YELLOW}[INFO]${NC} $filename: $closure_count total closure wrappers"
    fi

    if [ "$suppress_count" -gt 100 ]; then
        echo -e "${YELLOW}[INFO]${NC} $filename: $suppress_count 'suppress unused' comments"
    fi

    if [ "$file_has_issues" -eq 0 ] && [ "$closure_count" -lt 20 ]; then
        echo -e "${GREEN}[OK]${NC} $filename"
    fi
done

echo ""

# =============================================================================
# Go Syntax Check - catch undefined variables, type errors, etc.
# =============================================================================
echo "=== Go Syntax Check ==="

# Run go build to check for compile errors (without actually building)
go_errors=$(go build -o /dev/null "./$SIM_GEN_DIR" 2>&1 || true)

if [ -n "$go_errors" ]; then
    echo -e "${RED}[GO COMPILE ERRORS]${NC}"
    echo "$go_errors" | head -20

    # Count specific error types
    undefined_count=$(echo "$go_errors" | grep -c "undefined:" || true)
    multi_default_go=$(echo "$go_errors" | grep -c "multiple defaults" || true)

    if [ "$undefined_count" -gt 0 ]; then
        echo -e "\n${RED}[CODEGEN BUG]${NC} Found $undefined_count undefined variable errors"
        codegen_bugs="${codegen_bugs}  - Undefined variables in generated code (likely tuple/pattern matching codegen bug)\n"
        issues_found=$((issues_found + undefined_count))
    fi

    if [ "$multi_default_go" -gt 0 ]; then
        echo -e "\n${RED}[CODEGEN BUG]${NC} Found $multi_default_go 'multiple defaults' errors"
        codegen_bugs="${codegen_bugs}  - Multiple default cases in switch (tuple pattern matching codegen bug)\n"
        issues_found=$((issues_found + multi_default_go))
    fi

    # Check for type assertion errors (interface{} used where typed value expected)
    type_assertion_count=$(echo "$go_errors" | grep -c "need type assertion" || true)
    if [ "$type_assertion_count" -gt 0 ]; then
        echo -e "\n${RED}[CODEGEN BUG]${NC} Found $type_assertion_count 'need type assertion' errors"
        codegen_bugs="${codegen_bugs}  - Variables typed as interface{} instead of concrete types (let binding codegen bug)\n"
        issues_found=$((issues_found + type_assertion_count))
    fi
else
    echo -e "${GREEN}[OK]${NC} No Go compile errors"
fi

echo ""

# Detailed analysis for files with issues
if [ "$issues_found" -gt 0 ]; then
    echo "=== Detailed Analysis ==="
    echo ""

    # Find functions with deepest nesting
    for file in "$SIM_GEN_DIR"/*.go; do
        [ -f "$file" ] || continue
        if ! head -1 "$file" | grep -q "Code generated by ailang"; then
            continue
        fi

        filename=$(basename "$file")

        # Find the function with deepest nesting
        deepest_func=$(awk '
            /^func [a-zA-Z_]/ {
                func_name = $2
                gsub(/\(.*/, "", func_name)
                max_in_func = 0
            }
            {
                match($0, /^[\t ]+/)
                indent = RLENGTH
                if (indent > max_in_func) {
                    max_in_func = indent
                    deepest = func_name " (depth: " indent ")"
                }
            }
            END { print deepest }
        ' "$file")

        if [ -n "$deepest_func" ]; then
            echo "$filename: deepest function = $deepest_func"
        fi
    done

    # Check if we have codegen bugs that need reporting
    if [ -n "$codegen_bugs" ]; then
        echo ""
        echo -e "${RED}╔══════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║  AILANG CODEGEN BUGS DETECTED - DO NOT IMPLEMENT WORKAROUNDS     ║${NC}"
        echo -e "${RED}╚══════════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${CYAN}Detected codegen bugs:${NC}"
        echo -e "$codegen_bugs"
        echo ""
        echo -e "${CYAN}Required action:${NC}"
        echo "  1. STOP - Do not try workarounds"
        echo "  2. Report to AILANG using:"
        echo "     ailang messages send user \"<description>\" --type bug --github"
        echo "  3. Wait for AILANG team to fix"
        echo ""
        echo "This is an AILANG integration test project. Workarounds hide bugs."
    else
        echo ""
        echo "=== Recommendations ==="
        echo "1. Report to AILANG: List literals with expressions cause O(n) nested closures"
        echo "2. Report to AILANG: Chained 'match bool' creates nested closure per branch"
        echo "3. Consider: Use helper functions to reduce nesting in AILANG source"
        echo "4. Consider: Flatten list construction in AILANG codegen"
        echo ""
        echo -e "${RED}╔══════════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║  CRITICAL: Do NOT run 'go build' - compiler may hang!            ║${NC}"
        echo -e "${RED}║  Deeply nested closures cause exponential compile time.          ║${NC}"
        echo -e "${RED}╚══════════════════════════════════════════════════════════════════╝${NC}"
    fi
    echo ""
    echo -e "${RED}Found $issues_found codegen quality issues${NC}"
    exit 1
else
    echo -e "${GREEN}No critical codegen quality issues found${NC}"
    echo "Safe to run: go build ./..."
    exit 0
fi
